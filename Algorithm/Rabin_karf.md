# Rabin Karf
## 라빈 카프 알고리즘

문자열 매칭 알고리즘. <br/>
어떤 문자열 str에 대해 str이 어떠한 문구 substr을 포함하는지 탐색하는 알고리즘이다.<br/>
일반적으로 브루트포스로 조회하면 ```O(str.size() * sutstr.size())``` 의 시간복잡도를 가지게 되지만, <br/>
라빈 카프 알고리즘은 해시함수를 이용하여 그 시간을 단축한다.

## 원리

임의의 작은 소수 a와 큰 소수 b를 선택한다. <br/>
그리고 substr의 길이가 m이라고 할 때, m개의 문자데이터에 대해<br/>
b모듈러 상에서 ```a^(m-1), a^(m-2), ... , a^1, a^0```을 각각 곱해 더한다.<br/>
코드로 나타내면 다음과 같다.
```cpp
int sum = 0;
for(int i = 0; i < m; i++)
{
    sum *= a;
    sum %= b; // 오버플로 걱정이 없다면 해당 줄은 없애도 된다.
    sum += substr[i];
    sum %= b;
}
```
이런 방식으로 substr의 해시값을 구했다. <br/>
그런 후, 원본문자열인 str에서 ```str[i] ~ str[i+m - 1]``` 에 대한 해시값을 구해 비교하면 된다. <br/>

원본문자열에 대해 ```str.size() - substr.size() + 1``` 번의 해시값을 구해야할 것 같지만,<br/>
a의 거듭제곱으로 해시하였기 때문에 가장 왼쪽에 있던 문자에 대한 값을 빼고, 새로 추가되는 문자에 대한 값만 더하면,<br/>
i+1번째의 해시값이 된다.<br/>

결과적으로 해시값을 구하는 시간은 최초1회에 대해서만 ```O(substr.size())```의 시간이 소요되고, 이후로는 상수시간이 소요된다.<br/>
이 과정을 원본문자열 str에 대해 ```O(str.size())```회 반복하는 것이므로<br/>
동일한 해시값을 찾는데에는 ```O(str.size() + substr.size())```의 시간이 소요된다.<br/>

단, 해시값이 같다고 문자열이 매칭된 상황은 아닐 수 있다. 해시충돌을 기억하자.<br/>
해시값이 동일한 케이스를 발견하면 실제 문자열도 같은지 확인하면 끝.
