# 비트마스크
비트필드를 활용하여 이진수방식으로 자료구조를 활용하는 방식. <br/>

## 장점
사용하는 메모리의 크기를 줄일 수 있다. <br/>
특히 특정 상태를 표현하는 메모리를 8바이트 이내로 줄일 수 있다면? <br/>
해당 상태를 8바이트 정수로 다른 연산에 사용할 수 있다. <br/>
예 : [BOJ 1327 : 소트 게임](https://www.acmicpc.net/problem/1327) <br/>
해당 문제는 수열의 상태를 1~8의 숫자 8개로 나타낼 수 있기 때문에 8^8 = 2^24로, 4바이트 정수로 하나의 수열을 표현할 수 있게 된다. <br/>
해당 상태를 그대로 set또는 map에 넣어 조회할 수 있다는 것.

## 비트연산
&, |, ^, ~, <<, >>를 사용해 여러가지 동작을 수행할 수 있다. <br/>
주로 사용하는 형태는 각 비트를 나타내는 숫자를 미리 매핑해두고 사용하는 방식 <br/>
```cpp
int bits[10] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};

if (a & bits[i]) // a라는 비트필드에 i번째 비트가 1인지 확인

a |= bits[i] // a 비트필드에 i 비트를 켠다.
a ^= bits[i] // a 비트필드의 i 비트를 바꾼다 (0은 1로, 1은 0으로)
a &= ~bits[i] // a 비트필드의 i 비트를 끈다.

a | b // a와 b의 합집합
a & b // a와 b의 교집합
if (a & b) // a와 b가 서로소가 아니라면
a ^ b // a와 b중 하나에만 포함된 원소들의 집합
a & (~b) // a - b의 차집합
0 // 공집합
(1LL << k) - 1 // k개의 비트가 모두 켜진 꽉찬 집합
```
bits[i]는 1 << i로도 사용할 수 있다. (이 때 64비트의 비트필드를 사용하고 싶다면 1LL << i로 사용할것.)
