# Longest Increasing Subsequence

## 최장 증가 부분 수열

어떠한 수열이 주어졌을때, 해당 수열의 순서는 유지하되 수열의 숫자 0개이상을 제거하여 해당 부분수열이 증가하는 수열이 되면, 증가부분수열이라고 하며
이때, 주어졌던 수열의 증가부분수열 중 가장 긴 길이를 갖는 수열을 최장증가부분수열이라고 한다.

구하는 방법은 dp로 구하는 방법도 있고, 이진탐색을 사용하는 방법도 있다.

먼저 dp로 구하는 방법의 경우는
dp[]에 대해 dp[i]는 i번째 숫자를 포함하고도 나올 수 있는 가장 긴 길이를 저장한다.
그러면 input[i]에 대해 input[i]보다 작은 숫자를 i-1부터 0까지 차례로 검사해 처음 나오는 인덱스 idx에 대해
dp[i] = dp[idx] + 1을 대입하는 방식으로 진행할 수 있으며
마지막까지 진행한 후 최장 증가 부분 수열의 길이를 알 수 있다.
이 방법은 O(n^2)의 복잡도를 가진다.

두번째로 이진탐색을 이용하는 방법은
1. 배열을 준비한다.
2. 배열이 비어있다면 데이터를 삽입한다.
3. 배열의 마지막데이터보다 큰 데이터가 들어왔다면 배열의 끝에 입력데이터를 삽입한다.
4. 배열의 데이터보다 작은 데이터가 들어왔다면, 해당 데이터보다 크면서, 가장 작은 데이터의 자리에 입력데이터를 대입한다.

예를 들면 {3, 2, 4, 5, 3, 4, 7, 9, 8, 9, 6}라는 입력이 주어졌을 때
입력3에 대해 배열에 삽입하여 배열은 [3]의 상태가 된다.
입력2에 대해 0번째 인덱스에 2를 대입하여 배열은 [2]의 상태가 된다.
입력4에 대해 배열에 삽입하여 배열은 [2][4]의 상태가 된다.
입력5에 대해 배열에 삽입하여 배열은 [2][4][5]의 상태가 된다.
입력3에 대해 1번째 인덱스에 3을 대입하여 배열은 [2][3][5]의 상태가 된다.
입력4에 대해 2번째 인덱스에 4를 대입하여 배열은 [2][3][4]의 상태가 된다.
입력7에 대해 배열에 삽입하여 배열은 [2][3][4][7]의 상태가 된다.
입력9에 대해 배열에 삽입하여 배열은 [2][3][4][7][9]의 상태가 된다.
입력8에 대해 4번째 인덱스에 8을 대입하여 배열은 [2][3][4][7][8]의 상태가 된다.
입력9에 대해 배열에 삽입하여 배열은 [2][3][4][7][8][9]의 상태가 된다.
입력6에 대해 3번째 인덱스에 6을 대입하여 [2][3][4][6][8][9]의 상태가 된다.
결과는 6의 길이를 갖는 부분수열이 최장길이를 가지게 된다.
이때 마지막에 배열에 존재하는 수가 최장증가부분수열을 그대로 나타내는 것은 아니다. 실질적으로 길이6의 수열은 {3, [2], 4, 5, [3], [4], [7], 9, [8], [9], 6}와 같이 선택된 것이다.
하지만 중요한 것은 삽입연산이 발생하는 시점에 최장길이가 변하는 것이고, 삽입연산이 수행될 때에는 증가부분수열의 규칙이 지켜진다는 것이며 대입연산은 길이가 변하는 것은 아니기 때문에 길이를 구하는 데에는 문제가 없다는 것이다.
만약 수열 원본까지 필요한 경우는 대입로그를 작성하여 대입연산 일부를 제거하여 복구할 수 있다.
