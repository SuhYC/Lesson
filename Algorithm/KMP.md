# KMP
문자열 매칭 알고리즘.<br/>

현재 검사한 인덱스에서 일치하는 가장 긴 부분까지를 확인하여,<br/>
해당 부분에서의 접두사, 접미사로 일치하는 부분을 찾아 해결하는 알고리즘이다.<br/>

예시를 들면, ```abcab``` 까지 일치한 경우, ```ab```를 접두사로도, 접미사로도 사용할 수 있을 것이다.<br/>
그렇다면 인덱스를 1증가시켜 검사할 것이 아니고, 인덱스를 3증가시켜 접미사```ab```부분을 다음 검사 인덱스의 접두사로 삼아 검사하면 되는 것이다.<br/>

여기서 또 재미있는 방법이 사용되는데, <br/>
```str.size() >= fstr.size()```인 원본문자열```str```, 탐색할 문자열```fstr```에 대해서,<br/>
비교할 두 문자열 ```substr(str)```, ```fstr```에 대해 ```fstr```의 경우는 변하지 않지만,<br/>
```substr(str)```은 검사할 인덱스에 따라 변화한다.<br/>
이를 이용해 ```fstr```에 대해 미리 상태전이테이블을 만든다.<br/>

예를 들어 탐색할 문자열을 ```fstr = 'abcdaba'```라고 하자.<br/>
일치한 부분의 모든 경우의 수는<br/>
```''```, ```'a'```, ```'ab'```, ```'abc'```, ```'abcd'```, ```'abcda'```, ```'abcdab'```, ```'abcdaba'``` 이다.<br/>
각각의 일치하는 부분에 대해, <br/>
1, 1, 1, 1, 1, 4, 4, 6의 인덱스를 이동하면 된다. <br/>
해당 숫자를 구하는 방법은 접두사이면서 접미사인 부분인 경계에 대해 (```'abcdab'```에 대해 ```'ab'```가 경계다.) <br/>
```일치한 문자열의 길이 - 경계의 길이``` 와 같이 정리된다.<br/>

경계의 길이는 어떻게 간단하게 구할 수 있을까?<br/>

```cpp
  table.resize(stringlen+1);
  table[0] = -1; // 일치하는 부분이 없었다면, 1칸을 이동해야한다. 0 - (-1) == 1.
  int j = 0; // j : 현재까지 기록하던 경계의 길이

	for (int k = 1; k < stringLen; k++) {

		while (string[j] != string[k] && j > 0) { // 기록하던 경계가 있으며, 접두사와 접미사가 일치하지 않는 부분을 발견했다면
			j = table[j]; // 경계를 일치한 문자열로 보고 다시 그 안에서 경계를 찾는다.
		}

		if (string[j] == string[k]) { // 접두사의 마지막부분과 접미사의 마지막부분이 일치한다면
			table[k+1] = ++j; // 경계의 길이를 기록한다.
	}
```

위 코드에서 ```j = table[j]``` 부분이 굉장히 헷갈릴 것이다. <br/>
예를 들어 ``` A B A C A B A A ```와 같은 과정으로 진행하고 있었다고 가정하자.<br/>
이전 round에서는 ```A B A```를 경계로 가지고 있었다.<br/>
이번 round에서는 ```A B A C```와 ```A B A A```가 마지막이 C와 A로 달랐다.<br/>
새로 비교해야하는 부분은 ```A B A```와 ```B A A```이다.<br/>
```A B A```는 기존 경계문자열 그대로이지만, ```B A A```는 앞의 2문자만 경계문자열의 일부이다.<br/>
그러면 우리가 확인할 것은
1. ```B A A```의 선두 ```B A```가 ```A B A```의 선두 ```A B```가 일치하는가
2. ```A B A```의 마지막 문자 `A`가 ```B A A```의 마지막 문자 `A`가 일치하는가

이 두가지이다.<br/>
어차피 반복문에서 2번은 검사하므로 1번만 확인하면 되는데,<br/>
```B A A```의 선두 ```B A```는 또한, ```A B A```의 후미이다. (방금까지 k-1에서 경계였기 때문.)<br/>
즉, 1번의 검사는 기존에 하던 경계에 대한 검사라는 것이다.<br/>
그래서 ```j = table[j]```로 ```A B A```와 ```B A```에 대한 검사를 한 후, 마지막 문자에 대한 검사를 반복하여<br/>
k번째문자에 대한 round에서의 경계를 찾는 것이다.
