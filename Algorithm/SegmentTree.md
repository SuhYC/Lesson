# Segment Tree

이진트리의 형식이며,<br/>
실제 데이터는 가장 바닥의 리프노드에 존재하며,<br/>
자식을 가지고 있는 노드는 자신의 자식 노드의 정보를 담는 트리이다.

실제데이터의 크기 n에 대해, n개의 리프노드를 가장 바닥에 위치시켜야하므로<br/>
상당한 공간복잡도를 사용하게 된다.<br/>
나의 경우는 빠르게 세그먼트 트리를 구현하기 위해 n보다 크면서 가장 작은 2의 거듭제곱 pow2에 대해,<br/>
pow2 * 2의 공간을 갖는 배열을 할당하고, 실제 데이터를 pow2 ~ pow2+n-1번 인덱스에 담는다.<br/>
그리고 부모노드로 거슬러 올라가며 정보를 갱신한다.

## 구간합
구간합을 구하는 쿼리를 작성할 때 유용하다.<br/>
각각의 부모노드는 자식노드의 합을 기록하고,<br/>
특정 구간의 구간합을 요청할 때,<br/>
조회하려는 인덱스의 범위가 현재 범위에서 유효하면 해당 노드에서의 값을 리턴하고,<br/>
해당 노드의 정보가 구간을 벗어났다면 구간을 절반으로 나눠 자식노드에서 함수를 재귀적으로 요청한다.<br/>
이러한 방식으로 리턴되는 값을 모두 더하면 구간합이 완성된다.<br/>
ex) 16개의 데이터를 가지고 있고(세그먼트 트리는 32개의 노드를 가지고 있다.) 3~8번 인덱스의 합을 구하고 싶다
```
1. 0~15범위에서 함수를 요청하며 루트노드(1번인덱스)에서 출발한다.
2. 해당 범위는 구하려는 구간을 벗어나므로 0~7과 8~15로 요청한다.
3. 0~7은 0~3과 4~7로 분할되고 8~15는 8~11과 12~15로 분할된다.
4. 이때 12~15는 구하려는 구간과 관련이 없으므로 제외된다.
5. 0~3은 0~1과 2~3으로 분할되고 4~7에 해당하는 노드의 정보는 리턴된다. 8~11은 8~9와 10~11로 분할된다.
6. 0~1과 10~11은 제외된다.
7. 2~3은 2와 3으로 분할되고 3은 리턴된다. 8~9는 8과 9로 분할되고 8은 리턴된다.
8. 최종적으로 합산하기 위해 리턴된 노드는 3, 4~7, 8에 해당하는 노드이다.
```
