# 인덱스
테이블의 정보 검색 속도를 향상시키기 위한 데이터구조. <br/>
크게 2가지로 구분할 수 있다.

## 클러스터드 인덱스 (clustered index)
해당 컬럼을 기준으로 정렬된 테이블 상태를 유지한다. <br/>
행을 정렬된 상태로 만들어야하기 때문에 테이블 당 하나의 컬럼만 지정할 수 있다. <br/>
또한 데이터를 삽입, 수정, 삭제할 경우 정렬을 위해 행의 이동이 불가피할 수 있으므로 쓰기연산보다 읽기연산이 많은 테이블에 대해 유리하다.

## 넌클러스터드 인덱스 (non-clustered index)
해당 컬럼을 기준으로 어느 주소에 저장되어 있는지를 저장하는 포인터를 보관한다. <br/>
행이 정렬될 필요 없이 별도의 인덱스 구조로 검색속도를 향상시키기 때문에 여러 개의 컬럼을 지정할 수 있다. <br/>
또한 데이터의 삽입, 수정, 삭 연산이 발생하더라도 행을 이동시킬 필요가 없기 때문에 쓰기연산이 잦은 테이블에 대해 유리하다.

### 테이블 스캔 (Table Scan; Full Scan)
인덱스 지정이 안되어있는 경우 발생하는 조회. <br/>
행을 모두 검사하여 찾기 때문에 수행속도가 저하된다.


#### 구분
```Clustered Index``` : 루트페이지에서 찾는 데이터가 있는 데이터페이지를 찾아 해당 데이터 페이지를 조회한다.<br/>
```Non-Clustered Index``` : 루트페이지에서 찾는 데이터의 포인터가 저장된 리프페이지를 찾아 해당 데이터 페이지의 주소를 통해 행에 접근한다. <br/>

#### 장단점
```Clustered Index```
1. 읽기연산에 대해 빠른 속도를 보여준다.
2. ```Non-Clustered Index```에 비해 적은 공간을 차지한다.
3. 쓰기연산에 대해 느린 속도를 보여준다. (정렬 필요)
4. 데이터페이지가 꽉찼을 때 새로운 행이 추가되면 Balanced Tree 특성상 페이지를 분할하여 추가 시간이 소요된다.

```Non-Clustered Index```
1. 쓰기연산이 잦은 경우 ```Clustered Index```에 비해 빠른 속도를 보여준다.
2. 별도의 인덱스페이지를 저장할 공간이 필요하다.
3. 읽기연산에 대해 ```Clustered Index```에 비해 느리다.
