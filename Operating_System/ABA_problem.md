# ABA Problem
멀티스레드 환경에서 원자적 연산을 수행할 때 자료구조의 형태가 깨지는 문제. <br/>

## 원인
```A -> B -> C```의 형태로 자료구조가 구성되어 있었다고 가정해보자. <br/>
원자적연산으로 확인하는 건 내가 현재 바꾸려고 하는 데이터가 다른 실행흐름에 의해 변하지 않았는지이다. <br/>
하지만 어떤 실행흐름T1이 A가 Pop(A)를 실행하려고 Head노드인것을 확인한 상태로 문맥교환되어 <br/>
다른 실행흐름T2가 Pop(A), Pop(B), Push(A)의 순서로 실행했다고 가정하자. <br/>
다시 문맥교환되어 T1으로 돌아와 Pop(A)를 실행하려고 원자적 연산을 시도하는데 A가 그대로 Head노드이기에 <br/>
T1이 기존에 확인해 두었던 ```A->B->C```의 자료구조가 유지되어있는것으로 판단하여 B를 Head노드로 설정하고 A를 Pop하게 된다. <br/>
하지만 기존의 자료구조는 ```A->C```의 구조였기 때문에 C의 데이터는 B로 대체되어 잃어버리게 된다.

## 해결방법 (Stamp)
일반적으로 64bit 운영체제의 CPU는 가상메모리 주소를 52bit만 사용한다. 상위 12bit는 사용하지 않는다. <br/>
그러므로 상위 12bit에 연산이 시도된 횟수를 기록하여 <br/>
어떤 실행흐름이 원자적연산을 시도할 때, 다른 실행흐름이 연산을 시도하였는지를 검사할 수 있도록 하자.

사실 이 방법도 4096회마다 Stamp가 충돌할 가능성이 있다.. (스레드 문맥교환이 한바퀴 일어나는 동안 정확히 4096회 시도되면 충돌할 수 있다.)
