# 거짓 실패, 허위 실패, 우발적 실패
해당 단어가 한국어로는 어떤 번역이 맞는지 모르겠어서 다 적어봄. <br/>
C++의 atomic변수에는 ```compare_exchange_weak```연산이 존재하며, 이는 ```compare_exchange_strong```과 비교되는데, <br/>
두 연산은 모두 cas연산을 지원하며, ```swap```에 성공했다면 true, 실패했다면 false를 반환한다.

## 차이점
확실한 성공 실패를 1회만 시도하고 싶을 때는 ```compare_exchange_strong```을 쓰면 된다. <br/>
상관 없는 경우 ```compare_exchange_weak```를 쓰는게 성능상 유리하다.

### 차이가 생기는 이유
```compare_exchange_weak```는 ```Spurious Failure```를 발생시킬 수 있고,<br/>
```compare_exchange_strong```은 해당 문제가 없는 대신 엄격한 판단을 위해 추가비용이 발생함.

## Spurious Failure
수정하려는 값의 현재값이 변화되지 않았음에도 수정에 실패하는 현상. <br/>
딱 정의만 듣고서는 이해가 안 갈 수 있다.

### Spurious Failure가 발생하는 이유
1. 인터럽트 서비스 루틴의 발생 <br/>
 - 인터럽트가 발생하면 인터럽트 서비스 루틴을 호출하여 실행하고, 이후에 다시 원래 실행흐름으로 돌아온다. <br/>
 이를 코어에서는 문맥전환이 발생한 것으로 보고, 엄밀한 감시가 이루어지지 못했다고 판단하여 강제로 실패시킨다.
2. 캐시 무결성의 불확실성 <br/>
 - 멀티코어 시스템에서 각각의 코어는 각자의 캐시메모리를 사용하게 된다. <br/>
 이 때, 어떤 코어에서 cas를 시도하는 도중에 다른 코어가 해당 메모리를 접근하게 되면, <br/>
 값이 실제로는 변하지 않았더라도 확실한 판단을 위해 강제로 실패시킨다.
3. 파이프라인 충돌 <br/>
 - 여러개의 실행흐름이 효율적으로 병렬실행되기 위해서 CPU 파이프라인이 간섭받거나 [재배치되는 경우](https://github.com/SuhYC/Lesson/blob/main/C%2B%2B/Memory_Order.md)가 생긴다. <br/>
 이 파이프라인 재배치 또한 엄밀한 판단이 불가능하다고 판단하여 강제로 실패시킨다.

## Spurious Failure가 그럼 왜 성능상 이점을 가질까?
해당 상황이 발생하는 케이스가 빈도가 낮아 오히려 엄밀한 검증과정을 거치는 ```compare_exchange_strong```이 더 큰 비용을 감당하기 때문. <br/>

## 그러면 그냥 전부 compare_change_weak를 쓰는게 나은거 아니야?
꼭 그렇지는 않다. <br/>
물론 아키텍처에 따라 ```Spurious Failure```가 거의 발생하지 않는 케이스도 있지만, <br/>
상황에 따라 단 한번의 검증만 필요한 상황도 생긴다. <br/>
예를 들자면 한번의 체크를 수행한 후 조건분기해야하는 경우. <br/>
이 경우는 ```compare_exchange_weak```를 사용한 경우 ```Spurious Failure```가 발생하여 <br/>
가능한 상황으로 분기해야하는데 불가능한 상황으로 분기하게 될 수도 있다.
