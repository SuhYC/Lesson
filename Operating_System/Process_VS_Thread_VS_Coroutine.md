# Process vs Thread vs Coroutine
## 프로세스 vs 스레드 vs 코루틴

#### 동시성 = 병행성(Concurrency) : 논리적으로 작업이 동시에 실행되는 것처럼 보이는 것
#### 병렬성(Parallelism) : 물리적으로 작업이 동시에 실행되는 것

동시성 프로그래밍 이야기가 나오면 위 세가지를 종종 이야기하게 되는데, <br/>
이 세 방식의 차이점을 정리하고자 한다.

## 프로세스
실행중인 프로그램. <br/>
OS는 각 프로세스를 동시에 실행할 수 있도록 스케쥴링하여 여러 개의 작업이 동시에 실행되는 것처럼 보이도록 해준다.<br/>
(물론 멀티코어 CPU에서는 동시에 실행되기도 한다.) <br/>
각각의 프로세스는 독립적인 코드영역, 데이터영역, 스택영역, 힙영역을 할당받으며 <br/>
각 프로세스의 코드, 데이터, 스택, 힙 영역은 보호받는다. (다른 프로세스에서 원칙적으로 간섭할 수 없다.)

## 스레드
한 프로세스 내에서 실행되는 실행흐름. <br/>
모든 프로세스는 한 개 이상의 스레드를 갖는다. <br/>
스레드는 해당 프로세스의 코드영역, 데이터영역, 힙영역을 공유하며, 독립적인 스택영역을 갖는다.

## 코루틴
서브루틴을 일시정지하고 재개할 수 있는 구성요소 <br/>
일정 작업을 진행한 후 중단하여 특정한 상황을 기다린 후, 다시 재개하여 작업을 이어갈 수 있다. <br/>
하나의 작업은 Object가 되며, 실행흐름은 각 Object를 수행할 수 있다면 수행한다.

### 문맥교환 (Context Switching)
하나의 실행흐름을 중단하고 다른 실행흐름을 진입하기 위해 <br/>
기존의 실행정보를 저장하고, 다른 실행정보를 가져오는 데 걸리는 시간. <br/>

먼저, 프로세스 간 문맥이 교환되는 경우, <br/>
코드영역, 데이터영역, 스택영역, 힙영역을 공유하지 않으므로 해당 정보(TLB, 페이지테이블)를 교환하고, <br/>
실행되고 있던 작업의 상태(프로그램 카운터, 스택포인터, 기타 레지스터..)를 프로세스 제어 블록(PCB)에 저장하고 다음 프로세스의 정보를 불러오며, <br/>
파일 디스크립터나 네트워크 연결, 입출력 상태 등을 새 프로세스에 맞게 복원하는 과정이 포함된다.

다음으로 동일한 프로세스 내 스레드 간 문맥이 교환되는 경우, <br/>
코드영역, 데이터영역, 힙영역은 공유하므로<br/>
기존 스레드의 실행정보만 스레드 제어 블록(TCB)에 저장하고 다음 스레드의 정보를 불러오게 된다.

다음은 코루틴을 사용해 루틴 간 문맥이 교환되는 경우인데, <br/>
이 경우는 운영체제 수준의 문맥교환은 일어나지 않고,<br/>
현재 실행중인 위치와 지역변수 정도의 정보만 저장한 뒤 다음 루틴의 정보를 불러오게 된다.

### 스레드 vs 코루틴
프로세스와 스레드는 그래도 메모리영역에서 확연히 구분되지만, 스레드와 코루틴은 특히 혼동하기 쉽다. <br/>
스레드와 코루틴의 차이를 이해하려면 어떠한 작업을 기다리는 상황을 생각하면 쉽다. <br/>

만약, 멀티스레드를 이용해서 ```Task1```과 ```Task2```를 병렬실행하려고 하는데<br/>
```Task1``` 도중에 ```Task2```가 완료되어야지만 실행할 수 있는 부분이 있다고 하자. <br/>
이 경우 ```Thread1```은 ```Task1```을 실행하다가 ```Task2```의 완료를 기다리며 Block되게 된다. <br/>
그리고 ```Thread2``` 가 ```Task2```를 완료하는 순간, ```Thread1```이 다시 작업을 이어가게 된다. <br/>
스레드를 사용하여 해결한 경우, ```Thread1```은 ```Task2```가 수행되기 전까지 아무것도 하지 못하기 때문에 문맥교환이 일어나거나,<br/>
혹은 ```Task2```를 기다리며 자원을 낭비하고 있을 것이다.

하지만 코루틴을 이용해서 ```Task1```과 ```Task2```를 병행실행하려고 한다면,<br/>
```Thread1```이 ```Task1```을 실행하던 도중에 ```Task2```를 실행해야 한다는 것을 알아채고<br/>
```Task2```로의 서브루틴을 실행하여 작업을 수행한 후, ```Task1```으로 복귀하여 작업을 이어가게 된다.

가장 중요한 건 코루틴은 병행실행이며, 스레드는 병렬실행이라는 것이다. <br/>
코루틴의 루틴 전환이 일어나더라도 실행중이던 스레드는 변하지 않는다. 당장 실행해야하는 동작의 위치만 바뀐 것이다. <br/>
스레드를 사용하면 CPU_Cycle 사이의 버려지는 시간을 알차게 쓸 수 있는 것이고, <br/>
코루틴을 사용하면 작업 하나에 집중해야하는 스레드에 비해 적은 문맥교환 비용을 지불하고 여러 작업을 실행하게 되는 것이다.

### 코루틴은 언제 쓰면 좋을까?
주로 코루틴은 가벼우면서 대기시간만 긴 작업에 사용하기 좋다. <br/>
예를 들면 네트워크. <br/>
연결을 요청하는 것은 시간이 적게 들지만, 연결이 수락되었음을 확인하기까지는 오랜 시간이 걸린다. <br/>
또는, 데이터 수신을 기다리는 경우, 수신된 데이터가 있는지 확인하고 없다면 잠시 다른 일을 하는 것이 좋을 것이다. <br/>
만약 이 과정을 싱글스레드로 코루틴 없이 실행한다면, 대기시간동안 다른 아무런 동작도 할 수가 없다. <br/>
와이파이 연결 시도를 하는 동안 핸드폰이 먹통이 되어 아무런 입력도 받지 못한다면 정말 답답할 것이다.

### 코루틴의 한계
가벼운 작업에 사용하기 좋다고 언급한 것과 같이, 무거운 작업에서 작업분할을 제대로 해놓지 않는다면 문제가 될 수 있다. <br/>
예를 들어 매 초마다 200프레임의 화면을 그려내야 하는 경우를 생각한다면, <br/>
한 화면을 그려내는 작업은 5ms마다 수행되어야한다. <br/>
하지만 어떤 다른 코루틴을 통해 작업하는 것이 5ms를 넘게 사용한다면 프레임률이 떨어지는 결과가 나타날 것이다.
