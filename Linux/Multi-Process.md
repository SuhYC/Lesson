# 멀티프로세스
기본적으로 멀티프로세스 기반의 서버는 윈도우즈보다 리눅스에 적합하다. <br/>
윈도우즈는 리눅스에 비해 프로세스가 무거워 생성/해제하는 동작이 적합하지 않다.

## 리눅스 기반 멀티프로세스의 특징
1. ```fork()``` 함수를 통해 멀티프로세스 기반의 프로그램을 구현할 수 있다.
 - ```fork()``` 함수를 호출하면 프로세스의 복사본을 생성하여 두 프로세스 모두 ```fork()```함수 반환 이후 문장부터 실행하게 된다.
 - 메모리영역까지 동일하게 복사되며, 이후 pid값을 통해 부모프로세스와 자식프로세스를 구분하여 동작할 수 있도록 구성한다.
 - 부모프로세스는 ```fork()```함수의 반환값으로 자식프로세스의 pid를 전달받고, 자식프로세스는 0을 전달받는다.
2. 자식프로세스가 종료되면 좀비프로세스가 된다.
 - 자식프로세스는 인자와 함께 exit()을 호출하거나, return문을 통해 값을 반환하는 방식 등으로 종료할 수 있다.
 - 종료된 자식프로세스는 부모프로세스에게 인자값이나 반환값을 전달하기 위해 좀비상태가 된다.
 - 부모프로세스에서 해당 인자/반환값을 ```wait()```, ```waitpid()```함수 등으로 적극적으로 자식프로세스를 정리할 수 있다.
 - 부모프로세스가 먼저 종료된 경우, 자식프로세스는 init프로세스의 자식이 되어 자식프로세스가 종료될 때 init프로세스가 알아서 정리할 수 있다.

## 시그널 핸들링
### signal 함수
1. 부모프로세스에서 signal(SIGCHLD, mychild)와 같이 구성하여 자식프로세스 종료시 mychild함수를 호출하도록 할 수 있다. (이 함수는 ```void(int)```)형이어야한다.
2. 부모프로세스에서 signal(SIGCHLD, SIG_IGN)을 호출하여 자식프로세스의 인자/반환값을 무시하고 바로 정리되도록 할 수 있다. 다만 자식의 종료상태, 종료시점을 알 수 없다.

### sigaction 함수
sigaction 구조체와 함께 사용하여 시그널 핸들링이 가능한 함수이며, <br/>
플랫폼과 관계 없이 동일한 동작방식을 갖는다. 범용적으로 사용할 큰 프로젝트에서는 sigaction을 쓰는게 좋다.

### int signo
위 두 시그널 핸들링 함수에서 시그널의 종류를 선택할 수 있다. <br/>
1. SIGALRM : alarm함수를 호출해 등록해둔 시간이 된 상황 (보통 타임아웃을 위해 사용)
2. SIGINT : CTRL+C가 입력된 상황 (인티저가 아니고 인터럽트다.)
3. SIGCHLD : 자식 프로세스가 종료된 상황
... (시스템에 따라 번호도 종류도 다를 수 있다.)

한 프로세스에서 특정 시그널번호에 지정할 수 있는 시그널핸들링은 1가지 뿐이다. (같은 시그널로 여러 동작을 요청하면 마지막 요청된 동작만 수행한다.) <br/>
그러므로 동일한 SigNo로 서로 다른 동작을 유도하고 싶다면 결국 자식프로세스를 생성하고 자식프로세스의 SigNo에는 다른 동작을 수행하도록 하는 수밖에.. <br/>

## 멀티프로세스를 활용한 Linux서버
1. accept까지는 기존과 동일.
2. accept를 통해 받은 클라이언트 소켓의 정보를 저장
3. fork()를 통해 자식프로세스와 분리
4. pid체크를 통해 자식프로세스에서는 송수신함수 처리, 부모프로세스는 다시 돌아가 accept 처리

#### 주의사항. 부모프로세스는 자식프로세스에게 파일디스크립터(소켓)을 넘겨준 후 클라이언트소켓을 close해야하며, 자식프로세스도 넘겨받은 후 리슨소켓을 close해야한다.
운영체제의 같은 소켓에 다수의 연결이 된 경우 모든 연결이 끊겨야 정리할 수 있다. 각 프로세스에서 쓰지 않을 파일디스크립터는 바로 정리해주는 것이 좋다.
