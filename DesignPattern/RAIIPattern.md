# Resource Acquisition Is Initialization Pattern
## RAII 패턴
자원을 획득하고 반납하는 동작을 객체의 생명주기를 이용해 구현하는 디자인 패턴. <br/>
주변에서 흔히 볼 수 있는 RAII패턴으로 구현된 클래스는 ```스마트포인터```와 ```lock_guard```가 있다. <br/>
생성자를 통해 자원을 획득하고, 소멸자를 통해 자원을 반납함으로서 자원의 반납을 자동화한다. <br/>
(지역)변수가 선언될 때, 생성자를 호출하여 자원을 얻고, 스코프를 탈출하며 변수가 소멸하며 소멸자를 호출하여 자원을 반납한다.

## 목적
프로그래머가 종종 놓치는 실수가 자원을 제대로 반납하지 않는 경우이다. <br/>
메모리를 반납하지 않아 메모리누수로 이어지거나, mutex를 잠금하여 임계영역에 진입하였지만 해제하지 않아 교착상태에 빠지기도 한다. <br/>
특히 예외처리 과정에서 이러한 실수를 하기 쉬운데, 이를 방지하기 위해 ```RAII```패턴을 사용하는 것이 좋다. <br/>
예외를 던져 스택풀기를 시도하는 경우에 당연히 스코프를 빠져나오면서 자동으로 자원을 반납하기 때문.

## 생성자와 소멸자 주의사항
```RAII```패턴은 생성자와 소멸자를 통해 자원이 관리된다. <br/>
그런데 생성자에서 예외가 처리되지 않아 생성자를 빠져나오는 경우에 객체가 생성되지 않았기 때문에 소멸자가 호출되지 않고 메모리 누수로 이어질 수 있다. <br/>
이는 [스마트포인터를 생성자를 통해 생성하는 경우](https://github.com/SuhYC/Lesson/blob/main/C%2B%2B/std%3A%3Amake_shared.md)에도 발생할 수 있다. <br/>
소멸자의 경우는 [예외가 처리되지 않으면 런타임에 프로그램이 종료](https://github.com/SuhYC/Lesson/blob/main/C%2B%2B/Destructor.md)될 수 있다.

## 복사와 이동
일반적으로 복사는 금지하고 이동은 허용한다. <br/>
복사가 허용되는 경우는 ```shared_ptr```처럼 refCount를 통해 관리되는 경우. <br/>
그러한 경우가 아니라면 당연히 소멸자가 호출될 때 문제가 될 수 있다. <br/>
하나의 자원을 두 객체가 해제하려고 시도할 수 있기 때문이다.
