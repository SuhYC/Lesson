# 정밀도
어떠한 수 표기법상으로 표현가능한 가장 작은 단위로, 얼마나 정확하게 표현할 수 있는지이다. <br/>
흔히 부동소수점 타입에서 설명하나, 엄밀히 말하면 정수형도 1단위의 정밀도를 갖는다고 볼 수도 있다. <br/>

## 부동소수점
C++의 float 또는 double (long double)은 특정한 지수와 가수, 그리고 부호비트로 구성하여 수를 표현한다. <br/>
이진법으로 표현된 소수를 ```+- 1.??? ^ ???```의 형태로 표현한다고 가정하고 부호비트, 가수, 지수 순으로 데이터를 넣으면 된다. <br/>
단, 가수는 편향된 수를 사용하는데, 흔히 unsigned 타입과 동일하게 작동한다고 생각하면 된다. <br/>
그리고 ```1.???```에서 맨 앞의 1은 표기하지 않는데, 이는 단 하나의 경우를 제외하고는 무조건 앞에 1이 존재하기 때문이다. <br/>
단 하나의 경우라는 것은 ```0.0f```를 표기할 때인데, 이 경우는 특수화로, 모든 가수비트와 지수비트가 0으로 표기되면 그건 1.0을 의미하는게 아닌 0.0f로 인식한다. <br/>
근데 부호비트를 제외하고 0이므로 부호비트에 -를 입력해 -0.0f를 인식시킬 수도 있다. (단일 수로는 0.0f와 동일하지만 나누기 연산에서 다르게 인식된다.)

## 그럼 이러한 정밀도 상에서 연산의 순서를 바꿔도 같은 결과가 나올까?
단순히 예를 들어 ```A / B / C```와 ```A / C / B```는 같은 결과를 뱉을까? <br/>
아니다. <br/>
간단히 서로 다른 정밀도를 가진 경우를 계산해도 다른 결과가 나오고 <br/>
```cpp
int a = 5, b = 3;
float c = 2.0f;

(a / b) / c => (int)5 / (int)3 = 1, (int)1 / (float)2.0f = 0.5f;
(a / c) / b => (int)5 / (float)2.0f = 2.5f, (float)2.5f / (int)3 = 0.8333...f;
```
같은 정밀도 상에서도 가수표현이 정밀도를 넘어가면, 다른 결과가 나오기도 한다. <br/>

```cpp
float a = 100000000000000000000.0f, b = 3.0f, c = 7.0f;

std::cout.precision(30);

float s = a / b;
s = s / c;
std::cout << s << '\n'; // a / b / c

s = a / c;
s = s / b;
std::cout << s << '\n'; // a / c / b

결과 :
4761904595549028352
4761905145304842240
```
