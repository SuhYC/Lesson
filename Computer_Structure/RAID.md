# Redundant Array of Independent Disk
여러개의 디스크로 데이터를 저장하는 방식에 대한 설명이다.
한개의 대형 디스크를 사용하는 것보다 작은 여러개의 디스크를 연결해 하나의 큰 용량을 가진 디스크배열을 구성하면<br/>
저렴한 가격으로 더 큰 용량을 가진 디스크 서브 시스템이 구축가능하며<br/>
분산저장을 통해 액세스 속도를 향상시킬 수 있다.<br/>
다만 고장의 가능성이 증가한다. (MTTF가 단축된다.)

### Mean Time To Failure
디스크가 고장나는데 걸리는 평균시간. <br/>
단일디스크의 MTTF / 디스크의 수 로 계산되며 디스크가 100개면 100배 단축된 수명을 갖는다.

## RAID-0
모든 디스크에 데이터를 분할하여 사용한다. <br/>
여러 디스크에 동시에 입출력이 가능하므로 빠른 입출력이 가능하며 디스크의 공간을 100% 활용할 수 있다. <br/>
하지만 하나의 디스크라도 문제가 발생하면 모든 데이터를 잃어버릴 수 있다.

## RAID-1
데이터 인터리빙과 데이터 미러링을 사용한다.<br/>
같은 데이터를 2개의 디스크에 저장하여 쓰기 속도는 느리지만 읽기 속도는 조금 빠르며, 하나의 디스크에 문제가 발생해도 다른 디스크로부터 정보를 가져와 복구할 수 있다.<br/>
높은 신뢰를 요구하는 결함허용시스템에 사용된다.

### Data Interleaving (Block Interleaving)
데이터 블록들을 여러 디스크들로 이루어진 디스크 배열에 분산 저장한다.<br/>
균등 분산 저장을 위해 라운드 로빈 방식을 사용한다.

### Data Mirroring
데이터를 복사해 동일한 데이터를 저장한 공간을 만든다.

## RAID-2
비트단위 인터리빙 사용 : 데이터를 각 디스크에 비트단위로 분산 저장한다. <br/>
RAID-1보다 저렴하고 RAID-3보다 정밀하다.<br/>
해밍코드를 이용해 오류를 검출하고 정정한다.<br/>
대신 필요한 검사디스크 수가 많아 가격이 비싸다. (필요검사디스크수 C는 2^C - 1 >= G + C 로 계산된다. G : 데이터디스크수)

### Hamming Code
n개의 비트가 에러가 발생하는지 여부를 알기 위해 k개의 패리티 비트를 추가하여 n+k의 새로운 데이터를 만들어내는 형태이다.<br/>
이 때 2^k - 1의 각각은 n+k의 각 비트가 에러가 발생했는지를 가리켜야 하므로<br/>
2^k - 1 >= n + k 라는 식이 도출된다.<br/>
자세한 설명은 추후에 해밍코드 관련 문서를 작성하도록 하자.

## RAID-3
패리티 방식을 이용해 오류를 검출하고 정정한다. (해밍코드보다 정밀성이 떨어지지만 필요한 비트의 수가 적다)<br/>
하나의 디스크에서 결함이 발생했을 때 패리티비트를 통해 복구 가능하다.<br/>
병렬 데이터 읽기쓰기가 가능하여 액세스 속도가 향상된다.<br/>
쓰기 동작마다 패리티비트를 갱신해야해서 시간이 조금 지연된다.

### Parity Bit
xor를 이용해 여러개의 비트를 연산해둔 결과값이다.<br/>
정확한 오류 발생 지점을 찾기는 어려울 수 있지만 하나의 데이터가 변질되었을 때 그 데이터를 복구하는 건 쉽다.

## RAID-4
블록단위 인터리빙 사용. 데이터 디스크들의 동일한 위치에 있는 블록들에 대한 패리티 블록을 패리티 디스크에 저장.<br/>
쓰기 동작을 위해 패리티 디스크에 접근이 집중된다. -> 병목현상 발생

## RAID-5
RAID-4의 패리티 디스크 병목현상을 해소하기 위해 패리티블록을 라운드로빈 방식으로 구현하였다.<br/>
패리티블록을 각 디스크가 돌아가며 부담한다.<br/>
작은 쓰기 문제가 발생한다. (어느 한 블록만 갱신해도 여러 디스크를 액세스해야한다.)
### RAID-6
RAID-5와 비슷하나 패리티블록을 2개씩 사용한다.<br/>
패리티방식이 한번에 하나의 고장만 복구할 수 있던 것을 해결.<br/>
다만 당연히 사용할 수 있는 디스크 용량이 줄어들며, 이 경우 전용RAID컨트롤러가 필요하다.

# 상황에 맞는 RAID
일반적으로 0, 1, 5, 6을 단일로 사용하는 경우가 많다.<br/>
0은 저비용고용량 빠른입출력속도 낮은정밀도
1은 고비용저용량 빠른출력속도 느린입력속도 높은정밀도
5는 0방식과 1방식의 완충점이다

여기서 더 나아가 두가지 방식을 결합해 각각의 이점을 챙기는 방법도 있다.

## RAID-10
RAID-1 방식으로 구성된 디스크배열 여러개를 RAID-0방식으로 엮는다. <br/>
비용에 제한이 없다면 높은 안정성과 빠른 입출력을 보장받을 수 있다. (비용만 된다면..)

## RAID-50
RAID-5 방식으로 구성된 디스크배열 여러개를 RAID-0방식으로 엮는다. <br/>
충분한 안정성과 타협가능한 비용 그리고 빠른 입출력.

## RAID-60
RAID-6 방식으로 구성된 디스크배열 여러개를 RAID-0방식으로 엮는다. <br/>
RAID-50보다 높은 안정성과 RAID-10보다 낮은 비용(하지만 거의 투탑) 그리고 빠른 입출력.

### 이외의 방법
RAID-0+1이나 RAID-0+5, RAID-0+6의 경우는 복구에서 참혹한 성능을 보인다. <br/>
아직은 왜 쓰는지 잘 모르겠다. 하위배열이 RAID-0을 가지고 있기 때문에 하위배열에서 문제가 생기는 순간 해당 배열은 완전히 깨져버린다. 상위배열의 기능을 이용해 복구는 할 수 있겠지만 하위배열 하나를 통째로 갈아야되는거면..<br/>
RAID-15나 RAID-51은 그나마 더 정밀성을 추구한다면 사용해 볼 수는 있겠는데 입력속도가 문제가 있을거 같이 생겼다.
