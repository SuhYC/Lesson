# 소멸자 (종료자)
C#의 소멸자는 C++과 달리 GC가 메모리를 회수할 때 호출된다. <br/>
다만, GC가 직접 메모리를 회수하는 시점은 프로그래머가 예측할 수 없다. <br/>
메모리가 일정량 이상 사용된 경우나 특정 조건을 만족한 경우에 GC가 동작하기 때문. <br/>

몇가지 이유로 C#의 소멸자는 가급적 사용하지 않는 것이 권장되는데, <br/>
1. GC의 불확실성
- GC의 호출시점이 예측되지 않음
- GC가 회수하는 순서도 예측되지 않음
2. GC가 처리하는 것이 대부분의 경우에 이득
- 오히려 소멸자를 명시적으로 구현하면 GC는 클래스 정보를 따라올라가며 상속받은 Finalize()메소드를 호출함. <br/>
이 과정이 성능저하를 초래할 수 있음.
3. 소멸자 내에서 비동기 처리가 불가능
- 소멸자는 동기적으로 수행되며 소멸자 내에서 ```async/await```패턴을 사용할 수 없다. <br/>
소멸자 내에서 비동기 동작을 수행하는 건 권장되지 않는다.

또한 GC가 소멸자를 호출할지도 미지수이다. <br/>
프로그램의 종료시점에서 GC가 수행된다는 보장이 없다. <br/>

## IDisposable
using문과 IDisposable인터페이스를 사용해 명시적 메모리해제를 할 수 있다. <br/>
이 경우 GC에 의존하지 않는다.

```cs
class Myclass : IDisposable
{
  public void Dispose()
  {
    // 메모리 해제를 시도하기 전에 수행할 동작
  }
}
```

```cs
class Program
{
  static void Main()
  {
    using (var obj = new MyClass())
    {
      // 객체 사용
    } // Dispose 호출되며 자원이 해제
  }
}
```
