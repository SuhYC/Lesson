# 구조체
C++의 구조체는 접근지정자 관련에 대해서만 클래스와 다르고 대부분의 기능이 비슷했다. <br/>
하지만 C#의 구조체는 조금 다양한 부분에서 차이가 난다.

1. 할당되는 위치
- ```class```는 힙에 할당되는 참조형식이다. 하지만 ```struct```는 스택에 할당되는 값 형식이다.
2. 복사
- ```class```는 얕은 복사를 기반으로 하지만, ```struct```는 값 형식이기 때문에 깊은 복사를 기반으로 한다.
3. 인스턴스 생성
- ```class```는 new연산자를 사용하지만, ```struct```는 선언만으로 생성된다.
4. 생성자
- ```class```는 매개변수 없는 생성자를 생성가능하지만, ```struct```는 매개변수가 없는 생성자를 만들 수 없다. 그래도 ```CLR```이 기본값으로 초기화해준다.
5. 상속
- ```class```는 상속이 가능하지만, ```struct```는 값 형식이기 때문에 상속이 불가능하다.

## 왜 class가 있는데 struct를 쓸까?
```class```는 그 목적이 객체를 추상화하려는 것에 있지만 ```struct```는 여러가지의 데이터를 담는 것이 목적이다. <br/>
그렇기 때문에 객체지향의 원칙을 ```struct```에 강하게 적용하지 않는다. <br/>
은닉성 또한 강하게 적용하지 않기 때문에 대부분의 경우에 ```struct```의 필드를 ```public```으로 선언하는 경우가 많다.

## readonly struct
모든 필드와 프로퍼티의 값을 수정할 수 없는 구조체로 선언할 수 있다. <br/>
```readonly```키워드를 입력하면 해당 구조체 내의 모든 필드가 ```readonly```로 선언되도록 강제한다. <br/>
```readonly struct``` 내의 ```readonly```키워드를 사용하지 않은 필드와 프로퍼티는 컴파일 에러를 발생시킨다. <br/>
그리고 당연히 해당 ```readonly```필드와 프로퍼티를 수정하려고 하면 컴파일 에러가 발생한다.

## 매개변수가 없는 생성자
위에서 언급했듯 구조체는 매개변수가 없는 생성자를 만들 수 없다. <br/>
하지만 편법을 통해 매개변수 없이 생성자를 만들 수 있는데, <br/>
```cs
struct MyStruct
{
  public MyStruct(bool init = true) // 관용적으로 의미없는 bool 파라미터를 넣고 쓴다! 내부코드에서 해당 파라미터는 사용되지 않는다.
  {
    //...
  }
}
```
위 코드와 같이 의미없는 bool 파라미터를 넣는 것. <br/>
일단 가장 작은 사이즈의 파라미터기 때문에 스택메모리를 많이 먹지도 않고, 디폴트파라미터 처리까지 하면 호출측에서 파라미터를 굳이 적을 필요도 없다.
