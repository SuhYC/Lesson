# 생성자
객체를 생성할 때 호출되는 함수. <br/>
클래스와 이름이 같으며 반환형식이 없다. <br/>
오버로딩이 가능하며 명시적으로 생성자를 구현하지 않으면 컴파일러에서 기본생성자를 만든다. <br/>

## this() 생성자
자기자신의 생성자를 지목한다. <br/>
생성자 내에서만 호출할 수 있으며, 인수정보를 포함하여 어떤 생성자를 먼저 실행할 지 결정한다. <br/>
```cs
class MyClass
{
    public MyClass()
    {
        Console.WriteLine("this()");
    }

    public MyClass(int a) : this()
    {
        Console.WriteLine("this(a)");
    }

    public MyClass(int a, int b) : this(a)
    {
        Console.WriteLine("this(a,b)");
    }
}

static void Main()
{
    MyClass myClass = new MyClass(1,2);

}
```

결과 :
```
this()
this(a)
this(a,b)
```

## 배열할당
어떤 객체의 배열을 할당한다고 가정하면, C++에서는 각각의 객체를 모두 생성자를 호출하여 초기화를 해준다. <br/>
하지만, C#에서는 배열을 할당할 때, 공간만 할당하고 각각의 데이터는 기본값으로 설정된다. <br/>

class의 객체 배열을 생성하면 참조타입이기 때문에 null로 초기화된 배열을 얻게 되고, <br/>
struct의 배열을 생성하면 값타입이기 때문에 기본값으로 초기화된 배열을 얻게 된다. <br/>

덕분에 실수를 하게 되는 경우가 있는데, <br/>
예를 들면 Color[] 배열을 생성하는 경우, <br/>
Color는 struct이며, 이 경우 r,g,b,a가 모두 0f로 초기화된다. <br/>
하지만 C#에 익숙하지 않고 C++만 익숙한 경우 당연히 r,g,b 값만 넣은 생성자가 a를 1f로 초기화 하기 때문에 a가 1f일 것이라고 생각할 수 있다. <br/>
앞서 설명한 것처럼 배열을 할당할 때에는 생성자를 호출하는 개념이 아니기 때문에 당연히 a는 0f로 초기화되어있다.

## C#은 왜 C++처럼 멤버 이니셜라이저를 안쓸까?
[C++의 멤버 이니셜라이저](https://github.com/SuhYC/Lesson/blob/main/C%2B%2B/Constructor.md#%EB%A9%A4%EB%B2%84-%EC%9D%B4%EB%8B%88%EC%85%9C%EB%9D%BC%EC%9D%B4%EC%A0%80)는 초기화할 때의 오버헤드를 줄여주는 권장사항이다. <br/>
하지만 C#에서는 멤버 이니셜라이저 없이 본문초기화를 하는데, 그 이유는 주로 하는 복사의 방식이 다르기 때문이다. <br/>
C++은 일부 공유데이터를 제외하면 깊은 복사를 선호하며, 이는 자원을 복사하면서 큰 오버헤드를 유발할 가능성이 있다. <br/>
하지만 C#은 대부분의 케이스에서 얕은 복사를 선호하며, 이는 값타입의 복사와 큰 차이가 없기 때문에 2가지 방식을 혼용하는 것보다 본문 초기화로 통일하는 것이 사용면에서 낫다. <br/>

#### 아니 깊은 복사 얕은 복사는 둘 다 할 수 있는데 왜 선호하죠?
C++과 C#의 메모리 관리 방식 때문이라고 생각하자. <br/>
C#은 GC를 통해 CLR에서 메모리를 관리하며, 메모리 정리의 필요성이 생길 때 Mark & Sweep의 방식으로 메모리를 정리한다. <br/>
하지만 C++은 메모리 관리 책임을 객체가 갖는 방식으로 구현된 것이 많다. 애초에 RAII패턴으로 상당히 많은 클래스가 구현되어 있다. <br/>
C++은 공유포인터처럼 애초에 공유를 전제하고 만든 클래스가 아니라면 각 객체가 메모리의 소유권을 가지고 해제할 책임을 갖는다. <br/>
그렇기에 C++은 얕은 복사 방식이 잘 안맞는것. <br/>
하지만 C#은 자원을 분리하여 소유할 것이 아니라면 얕은 복사방식으로 관리되는 경우가 많고, 그렇게 관리하더라도 루트에서 접근불가하면 전부 해제해버리면 되니까 메모리 관리 책임이 적다! <br/>

물론 C++이라고 깊은복사만 하는 것도 아니고, C#이라고 얕은복사만 하는 것도 아니니 그건 유념하도록하자.
