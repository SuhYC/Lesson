# 가비지 컬렉션
프로그래머가 메모리 관련 문제로부터 자유로울 수 있도록 돕는 자동메모리관리기능 중 하나 <br/>
더 이상 사용하지 않는 객체를 수거하여 메모리를 확보한다.

## Unmanaged Code
CLR은 ```Managed Code```를 관리한다. <br/>
일반적인 C#의 코드로 수행되는 메모리를 할당하는 동작이나, 보안, 스레딩 등의 임무와 GC까지 책임진다. <br/>
하지만 CLR이 관리하지 않는 ```Unmanaged Code```도 작성할 수 있다. <br/>
```unsafe``` 키워드를 이용하여 ```Unmanaged Code```를 작성할 수 있는데, 이 경우 CLR이 제공하는 서비스를 받을 수 없다.

## 루트
어떠한 객체가 생성되어 다른 데이터가 참조하고 있을 때, 그 다른 데이터를 루트라고 한다. <br/>
예를들어 어떤 지역변수에 새 객체를 만들어 참조를 부여하면, 지역변수가 루트이며 <br/>
지역변수는 스택에 저장되어 있지만, 실제 데이터인 객체는 힙 영역에 있다. <br/>
루트는 지역변수일 수도, 정적변수일 수도, 애플리케이션도메인에 등록된 객체일 수도, CPU레지스터에 저장된 경우일 수도 있다.

## GC가 실행된다면?
힙에 남아있는 객체들의 루트를 조사하여 루트가 존재하지 않는 객체를 수거한다. <br/>
과정은 다음과 같다. <br/>
1. GC는 힙의 모든 객체가 수거대상이라고 생각한다.
2. 루트들의 목록을 순회하며 아직 참조되고 있는 객체를 수거대상에서 제외한다.
 - 단, 어떤 루트가 참조하는 객체가 다른 힙 객체를 참조하고 있다면, 그 객체도 해당 루트가 참조하는 것으로 간주한다.
3. 루트들의 순회가 끝났을 때 아직 수거대상인 객체들을 쓰레기로 간주하여 수거한다.
4. 수거된 쓰레기가 차지했던 공간을 채울 수 있도록 인접 객체를 이동시켜 차곡차곡 채워 넣는다.
5. 정돈이 끝난 메모리의 비어있는 공간 중 가장 앞선 주소를 다음 객체가 할당될 메모리의 포인터로 설정하고 GC를 종료한다.


## 세대별 GC
객체가 생성되고 소멸하는 과정에서, <br/>
어떤 객체는 금방 사라질 객체이지만 어떤 객체는 프로그램의 수명과 비슷한 수명을 가질 수도 있다. <br/>
전자는 자주 수거해주어야하지만, 후자는 수거의 빈도가 적어도 된다. <br/>
GC가 한번 수행할 때마다 꽤많은 자원을 사용하기에 GC 또한 유형을 나누어 수행할 수 있다. <br/>

세대별GC는 다음과 같은 과정을 통해 수행된다. <br/>
0세대 객체, 1세대 객체, 2세대 객체로 구분한다. <br/>

0세대 객체들의 총 크기가 0세대 가비지 컬렉션 임계치에 도달하면, 0세대 객체들만 GC를 수행한다. <br/>
0세대 GC가 수행된 후 살아남은 객체들은 1세대 객체가 된다. <br/>

1세대 객체들의 총 크기가 1세대 가비지 컬렉션 임계치에 도달하면, 1세대 객체와 0세대 객체를 GC를 수행한다. <br/>
1세대 GC가 수행된 후 살아남은 0세대 객체는 1세대 객체가 되며, 1세대 객체는 2세대 객체가 된다. <br/>

2세대 객체들의 총 크기가 2세대 가비지 컬렉션 임계치에 도달하면 모든 객체를 GC를 수행하며 이를 ```Full GC```라고 한다. <br/>
```Full GC```가 수행된 후 살아남은 0세대 객체는 1세대 객체가 되며, 1세대 객체와 2세대 객체는 2세대 객체가 된다. <br/>

0세대 GC가 발생해도 1세대 객체와 2세대 객체는 GC를 수행하지 않으며 <br/>
1세대 GC가 발생해도 2세대 객체는 GC를 수행하지 않는다. <br/>
즉, 2세대 객체에 가까울 수록 수명이 긴 객체로, GC를 적은 빈도로 수행하게 된다.

## GC의 원리를 이해하고 다음으로 할 것
```Full GC```를 수행하는 것은 굉장히 큰 자원을 소모한다. <br/>
애플리케이션의 수행을 잠시 멈추고 메모리를 확보하기 때문에 ```Full GC```가 최소한으로 실행되도록 해야한다. <br/>

GC를 바탕으로 최대한 효율적인 코드를 구성하기 위한 방법은 다음과 같다.
1. 객체를 너무 많이 할당하지 말 것.
 - CLR의 할당 속도가 빠르긴 하지만 너무 많은 객체는 관리되는 힙의 각 세대에 메모리 포화를 초래하며 빈번한 GC를 부르게 된다.
 - 필요한 객체인지 고려하는 것이 좋다.
2. 너무 큰 객체의 할당을 피할 것.
 - CLR은 85KB이상의 대형 객체에 대해 대형 객체 힙을 따로 유지한다.
 - 대형 객체 힙에서는 GC가 수행될 때 인접 객체를 앞으로 당기지 않는다. (큰 객체는 복사 비용도 크기 때문)
 - 할당 시에도 해당 크기의 객체를 만들 수 있는 공간이 있는지 탐색한다. (소형 객체 힙은 GC가 수행될 때마다 앞으로 정돈되기 때문에 포인터가 가리키는 공간에 바로 할당할 수 있다.)
3. 너무 복잡한 참조관계를 만들지 말 것.
 - GC가 끝나고 인접객체의 주소가 변하면서 기존 객체 간 참조 관계를 조사하여 메모리 주소를 모두 수정한다.
 - 참조관계가 복잡하면 그만큼 더 많은 주소를 조사하고 수정해야한다.
4. 루트를 너무 많이 만들지 말 것.
 - 루트의 목록을 모두 순회하여 GC를 수행하기 때문에 루트목록이 적을수록 유리하다.
