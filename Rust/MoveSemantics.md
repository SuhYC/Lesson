# 이동 의미론
C++의 생성자에서 이동생성자와 이동대입연산자에 대해 언급한 적이 있다. <br/>
이는 이동 의미론이 적용된 특수한 생성자 및 연산자인데, <br/>
Rust에서는 특히 그 이동 의미론이 대부분의 영역에서 강력하게 적용된다. <br/>

## 이동
복사와 이동의 차이는 뭘까? <br/>
한때 새 객체에 데이터가 씌워지는 것은 동일하고 기존 객체의 데이터를 초기화한다 라는 점만 알고 있던 때가 있었다. <br/>
하지만 더 정확한 의미의 이동은 ```소유권의 이전```이다. <br/>
소유권이 이전된다는 의미는 또 무엇일까? <br/>
```소유권```은 해당 데이터를 해제할 권리 정도로 생각하면 된다. <br/>
소유권을 이전시켰다는 것은 즉 기존 객체에서는 해당 데이터에 대해 해제할 권리를 잃어버렸다는 뜻이고, 새 객체가 그 권리를 이어받았다는 의미이다. <br/>
C++의 이동생성자 및 이동대입연산자가 호출되면, 기존 객체의 데이터가 모두 새 객체에 전달되지만, <br/>
기존 객체가 가지고 있던 데이터는 초기화하여 혹시라도 기존 객체가 소유권을 잃어버린 메모리를 해제하지 못하도록 하는 것이다. <br/>
즉 복사생성자와 이동생성자의 차이로 기존 데이터를 초기화하는 작업이 들어갔던 이유가 소멸자 등에서 이미 소유권을 잃어버린 메모리를 건들지 못하도록 하기 위해서이다.

## 그래서 Rust에서는 이동이 어떻게 적용되는데?
일반적으로 Rust에서는 데이터를 다른 데이터로 옮기게 되면 기존 데이터는 미초기화 상태로 변하며 새 데이터에 그 소유권이 이전된다. <br/>
소유권이 이동할 뿐이지 언제나 그 소유자는 하나를 유지하게 된다. (물론 CopyType처럼 이동의미론이 적용되지 않는 데이터는 예외다.) <br/>
특히 조건문이나 반복문 사용에 유의할 것! <br/>
조건문에서 데이터의 이동이 발생하여 기존 객체가 미초기화 상태로 넘어갔는데 조건문이 끝난 이후에 다시 재참조를 하려고하면 에러가 발생한다. <br/>
```rust
let x = vec![10, 20, 30];
if c{
  f(x); // 1번
} else {
  g(x); // 2번
}
h(x); // 1번 또는 2번을 반드시 거치며 x가 미초기화상태로 바뀐다! 에러!
```
반복문도 마찬가지. 반복문 내에서 어떤 데이터를 가져오게 되면서 미초기화 상태로 넘어가면, 다음 반복 이전에 다시 데이터를 할당하는 작업이 필요하다. <br/>
```rust
let x = vec![10, 20, 30];
while f() {
  g(x); // x가 미초기화 상태로 바뀐다! 다음 반복이 발생하면 바로 에러!
}
```
