# Tree
## 트리 (Tree)
부모-자식 관계로서 정의하는 자료구조. 루트노드를 제외한 모든 노드는 단 하나의 부모노드를 갖는다. <br/>
나무가 거꾸로 뒤집혀 있는 것 같은 모양으로 데이터가 그려진다.

### 트리 용어
- 루트노드(root node) : 부모가 없는 노드. 트리의 출발점. 트리마다 하나만 존재.
- 단말노드(leaf node) : 자식이 없는 노드.
- 내부노드(internal node) : 리프노드가 아닌 노드.
- 링크(link) : 노드를 연결하는 선. 나무니까 branch로 부르는 경우도 있고 그래프니까 edge(간선)로 부르는 경우도 있다.
- 형제노드(sibling node) : 같은 부모를 가진 노드.
- 노드의 크기(size) : 자신을 포함한 모든 자손노드의 개수. (자식의 자식들도 세고 그 아래도 센다.)
- 노드의 깊이(depth) : 루트부터 출발해 해당 노드에 도달하기 위해 거쳐야하는 간선의 수
- 노드의 레벨(level) : 특정 깊이를 갖는 노드의 집합.
- 노드의 차수(degree) : 각 노드가 가진 가지의 수.
- 트리의 높이(height) : 모든 노드 중 가장 깊숙히 있는 노드의 깊이

## 이진트리 (Binary Tree)
자식의 수가 최대 2개인 트리이다. <br/>
여기에 왼쪽자식노드는 부모노드보다 작고 오른쪽 자식노드는 부모노드보다 크다는 조건을 걸면 이진탐색트리(Binary Search Tree)가 된다. 이 경우 원하는 데이터를 탐색하는데 걸리는 시간이 평균 O(logn).

## 힙트리 (Heap Tree)
최소힙, 최대힙으로 구분할 수 있으며<br/>
최소힙은 모든 부모노드가 자신의 자식노드보다 작거나 같은 트리를 지칭하며, 최대힙은 반대로 모든 부모노드가 자신의 자식노드보다 크거나 같은 트리를 지칭한다. <br/>
해당 트리를 이용하여 우선순위 큐를 만들 수 있다.

## AVL 트리
자가균형 이진탐색트리의 일종이다.<br/>
Balance Factor를 이용하여 치우친 정도를 계산하며 이 수치가 -1 ~ 1 범위를 벗어난다면 균형이 무너진것으로 간주하고 회전한다.<br/>
BF가 2이상 -2이하로 바뀐 노드를 기준으로 Rotation한다.

## RB트리 (Red Black Tree)
자가균형 이진탐색트리의 일종이다.<br/>
C++ STL의 Set과 Map이 해당 자료구조로 구현되어 있다.<br/>
자가균형을 위해 이진탐색트리에 다음 조건을 추가한다. <br/>
1. 모든 노드는 레드 혹은 블랙이다.
2. 루트 노드는 블랙이다.
3. 모든 NIL노드(자식이 없는 곳에 가상의 노드를 가정. 이를 NIL노드라고 한다.)는 블랙이다.
4. 레드노드는 레드노드를 자식으로 가질 수 없다.
5. 임의의 한 노드에서 NIL노드까지 도달하는 모든 경로에 항상 같은 수의 블랙노드가 있다.

4번과 5번에 의해 어느정도 균형이 잡혀있다고 표현할 수 있다. (경로의 길이가 가장 긴 경로도 가장 짧은 경로의 2배를 넘지 못한다.)

### AVL트리와 RB트리의 장단점
1. AVL트리는 RB트리보다 더 엄격한 균형을 이루기 때문에 탐색에서 더 좋은 효율을 보인다.
2. RB트리는 AVL보다 느슨한 균형을 유지하기 때문에 삽입/삭제 연산에서 더 좋은 효율을 보인다.
3. AVL트리는 BF를 계산하고 저장하기 때문에 노드마다 충분히 큰 데이터를 추가하여야 한다. (ex. int형 데이터)
4. RB트리는 color만 저장하고 red/black 2가지뿐이므로 노드당 1비트의 정보만 추가하면 된다. (비트마스크를 이용한다면 확실한 공간 압축이 될듯..)
5. 탐색이 중요하냐 삽입삭제가 중요하냐에 따라 사용하면 되겠다.
