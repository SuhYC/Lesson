# Sort
## 정렬

### Bubble Sort (버블정렬)
공기방울이 수면으로 올라오는 방식을 떠올리면 된다. <br/>
0 ~ n-1의 인덱스가 있을때,<br/>
0번 인덱스부터 n-2번째 인덱스까지 자신의 다음인덱스와 비교하여 다음인덱스의 데이터가 더 작으면 데이터를 swap한다.<br/>
한바퀴 수행이 끝나면 가장 큰 원소는 정렬된 상태가 된다. 앞쪽부터 비교하고 큰 원소를 뒤쪽으로 계속 밀었기 때문.<br/>
모든 원소가 정렬된 상태가 되도록 n바퀴 수행하면 정렬이 끝나게 된다.<br/>
그러므로 시간복잡도는 최악의 경우 O(n^2)이 된다.

### Selection Sort (선택정렬)
가장 작은 데이터를 선택하여 정렬한다.<br/>
현재 범위에서 가장 작은 데이터를 맨 앞 데이터와 swap하는 과정을 n번 수행한다.<br/>
버블정렬이 뒤쪽부터 정렬된다면 선택정렬은 앞쪽부터 정렬된다.<br/>
0번 인덱스를 정렬할때는 0 ~ n-1의 인덱스를 조회하여 가장 작은 데이터의 인덱스를 기록하고 조회가 끝나면 해당 인덱스와 0번 인덱스의 데이터를 swap한다.<br/>
k번 인덱스를 정렬할때는 k ~ n-1의 인덱스를 조회하여 가장 작은 데이터의 인덱스를 기록하고 조회가 끝나면 해당 인덱스와 k번 인덱스의 데이터를 swap한다.

버블정렬과 다른 점은 앞뒤 어느쪽으로 정렬되는가 도 있지만<br/>
swap에도 시간이 들어간다. 데이터 하나를 제 위치에 놓는데 여러번의 swap이 필요한 버블정렬보다는 좋지만 선택정렬 또한 O(n^2)의 복잡도를 갖는다.

### Insertion Sort (삽입정렬)
k번 인덱스를 정렬하는데 k-1 이하 인덱스 중 들어가야할 위치를 찾아 넣고 이후의 데이터를 전부 뒤로 밀어낸다.<br/>
공간복잡도는 조금 유리할지 몰라도 결국 이 정렬도 O(n^2)이며 들어가야할 위치를 찾는 과정을 이진탐색을 사용하더라도 데이터 자체의 이동에 굉장한 시간이 소요될 수 있다.

### Merge Sort (합병정렬)
각각의 원소를 1개씩 분리한다.<br/>
이전 단계에 있는 각 그룹은 정렬된 상태이다. 2그룹씩 묶어 서로 비교하며 합병시킨다.<br/>
예를 들어 이전 단계의 그룹 {1,3}과 {2,5}가 있다면 1과 2를 비교하여 1을, 3과 2를 비교하여 2를, 3과 5를 비교하여 3을, 이후 5를 새로운 그룹으로 만들어 삽입한다. 그러면 데이터는 {1,2,3,5}의 순으로 만들어지며 이는 정렬된 상태이다.<br/>
이 경우 메모리가 꽤 크게 소요된다. 각 단계마다 이전데이터가 저장된 공간과 새롭게 만들어질 데이터가 저장된 공간 이렇게 2배씩의 공간을 요구하게 된다.<br/>
시간복잡도상으로는 O(nlogn)으로 다소 유리할지 모르나 데이터의 크기가 커지면 공간복잡도 또한 생각을 해야한다.

### Heap Sort (힙정렬)
힙트리라는 자료구조를 이용한 방식이다.<br/>
힙트리란, 부모노드가 자식노드보다 항상 크거나(최대힙), 반대로 항상 작은 경우(최소힙)에 성립하는 완전이진트리 이다.<br/>
최대힙트리든 최소힙트리든 어쨋든 루트노드는 해당 트리에서 가장 크거나 가장 작은 값이므로<br/>
힙트리에 모든 데이터를 삽입하고, 힙트리의 루트노드를 출력하고 트리에서 제거한다.<br/>
트리가 원소를 가지지 않을때까지 반복한다.<br/>
시간복잡도상으로 O(nlogn)이며 합병정렬에 비해 추가적인 메모리가 필요하지 않은 정공법이다. 대부분의 상황에서 준수한 성능이 나온다.<br/>
priority_queue가 힙트리를 이용해 구현되어 있으니 priority_queue에 데이터를 모두 삽입하고 pop하여 순서대로 정리하면 원리를 이해하기 쉽다.

### Quick Sort (퀵정렬)
pivot이라는 기준점을 잡고 pivot보다 작은 원소는 pivot보다 앞에, 큰 원소는 pivot보다 뒤에 위치하도록 하며<br/>
이후 pivot 앞쪽과 pivot 뒤쪽에 대해 각각 다시 Quick Sort를 재귀호출하여 그 크기가 0 또는 1로 작아질때까지 진행하는 방법이다.<br/>
이때 pivot을 어떤 기준으로 선택하느냐가 상당히 중요해진다.<br/>
pivot을 최소 또는 최대만 선택하게 되는 최악은 O(n^2)이며 일반적인 상황에서는 O(nlogn)이다.

### Tree Sort (트리정렬)
이진탐색트리를 이용해 정렬하는 방법이다.<br/>
부모의 왼쪽으로는 부모보다 작은 원소를, 오른쪽으로는 부모보다 큰 원소를 삽입하여 중위순회하면서 정돈하면 된다.<br/>
1개의 데이터에 대해 삽입연산은 평균 O(logn)이니 일반적인 경우 O(nlogn)의 복잡도를 갖는다.

### Counting Sort (계수정렬)
입력데이터의 범위가 크지 않은 특수상황에서 쓸 수 있는 정렬이다.<br/>
예를 들어 1~10까지의 숫자가 랜덤으로 10만개가 적혀있을 때 사용하기 좋으며<br/>
앞부터 순회하여 특정 숫자가 몇번 나왔는지 세어<br/>
이후 나온 횟수대로 앞쪽부터 적어주면 된다.<br/>
1이 3번 2가 4번 3이 2번이면<br/>
1,1,1,2,2,2,2,3,3 과 같이 정렬이 되는 것이다.<br/>
숫자범위가 커지면 기록할 배열이 크기가 커지기 때문에 사용하기 어렵다.<br/>
복잡도는 O(n).

## Stable_Sort (안정정렬)
정렬법들 중 동일한 크기를 가진 원소들의 순서가 유지되는 정렬법을 말한다.<br/>
안정정렬의 예로는 버블정렬, 삽입정렬, 합병정렬, 계수정렬이 있다.<br/>
불안정정렬의 예로는 선택정렬, 힙정렬, 퀵소트가 있다.
