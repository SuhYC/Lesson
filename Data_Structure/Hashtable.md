# 해시테이블
해시함수를 사용하여 O(1)의 탐색속도를 갖는 해시기반 자료구조. <br/>

## 버킷
삽입한 데이터가 실제로 저장된 자료구조. 보통 ```LinkedList```나 ```ArrayList```를 사용한다.

## 해시함수
삽입한 데이터의 키를 해시함수로 해시한 값으로 버킷을 지정하여 저장하거나 참조한다. <br/>
간단하게 구성한다면, 키를 해시함수를 통해 정수값으로 바꾼 뒤, 해당 정수값을 버킷의 수로 모듈러연산하여 버킷을 지정할 수 있다. <br/>
해시함수의 성능에 따라 정말 빠른 속도로 접근할 수 있다.

## 해시충돌
서로 다른 키 ```a```,```b```로부터 해시함수의 결과값 ```a'```,```b'```를 생성하였을 때, <br/>
```a'```와 ```b'```가 동일한 버킷을 가리키게 되는 경우가 있다. <br/>
이 경우를 해시충돌이라고 하며, 체이닝 등의 방법으로 처리한다. <br/>
해시충돌이 적게 발생하는 해시함수가 좋은 해시함수이다.

## 체이닝
버킷을 ```LinkedList```같은 자료구조로 다시 구성하여 해시충돌된 값들을 여러개 보관한다. <br/>
해시충돌로 인해 저장할 수 없던 문제를 해결했으나 체이닝으로 구성한 버킷이 요소 수가 많아지면 탐색속도가 O(n)으로 느려진다.

## 오픈 어드레싱
해시충돌이 발생한 버킷을 피해 다른 버킷에 저장한다. <br/>
비어있는 버킷을 탐색하는 방법은 선형탐색, 이차탐색, 이중해싱 등이 있다. <br/>
저장할 수 없던 문제는 해결했으나 버킷의 수보다 많은 데이터를 저장할 수는 없다.

### 선형탐색
해당 버킷으로부터 비어있는 버킷을 발견할 때까지 다음 버킷을 탐색한다.
### 이차탐색
해당 버킷으로부터 비어있는 버킷을 발견할 때까지 이차식을 사용하여 다음 버킷을 탐색한다.
```cpp
idx = h(k) + c1 * i * i + c2 * i;
```
### 이중해싱
해시충돌에 대비하여 해시함수를 2개 준비한다. 두번째 해시함수를 사용하여 버킷을 다시 탐색한다.

## rehashing (버킷 재구성)
어떤 방식이든 해시충돌이 발생했을 때, 이를 우회하면 언젠가는 문제가 생긴다. <br/>
체이닝은 탐색속도가 느려지며, 오픈 어드레싱은 결국 버킷이 모두 사용되면 문제가 된다. <br/>
이를 해결하기 위해 버킷을 새로 구성할 수 있다. 버킷의 수를 조정하여 해시충돌이 발생하지 않도록 할 수 있다. <br/>
다만, 버킷을 새로 만들고 데이터를 옮기는 과정에서 상당한 오버헤드가 발생한다.
