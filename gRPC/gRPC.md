# gRPC
구글에서 개발한 RPC.

## RPC (Remote Procedure Call)
다른 마이크로시스템의 메서드를 호출할 수 있도록하는 기술.

## 사용하게 된 이유
작성하던 토이프로젝트에서 클라이언트가 어떠한 목적을 가지고 행동을 서버에 요청할 때, <br/>
MessageType이라고 만든 enum class와, 해당 값마다 매핑된 파라미터의 구조를 구조체로 만들어 JSON으로 직렬화 한 후 전송하였다. <br/>
Ex)
```JSON
{
  "Type": 0, //MessageType::SIGNIN => 0. 호출할 함수 번호나 마찬가지.
  "ReqNo": 1, //클라이언트가 요청한 요청의번호. 결과통지시에 해당번호를 함께 보낸다.
  "msg": "{\"ID\": \"psyc\", \"PW\": \"1234\"}" //실질적 파라미터
}
```

그런데 JSON으로 이 처리를 하려다보니
1. 구조체 선언
2. 구조체에 맞게 JSON파싱이 가능한지 유효성 검사
3. JSON 직렬화 함수 및 역직렬화 함수 구현

생각보다 시간이 많이 걸린다.. <br/>
거기에 JSON을 사용하기 때문에 전송데이터의 규모도 커지는건 덤.

## 왜 gRPC를 쓰면 더 나을까?
기존방식은 JSON직렬화된 문자열을 사용하기 때문에 Key가 직접 포함되며, Value또한 문자열로 기록되기 때문에 데이터의 크기가 팽창할 수 있다. <br/>
ex. ```(int)1234567``` : 4bytes, ```const char*)"1234567"``` : 8bytes <br/>

하지만 gRPC는 protoBuf를 사용해 직렬화를 하는데, 이는 텍스트기반이 아닌 바이너리데이터 기반의 직렬화를 하기 때문에 크기가 팽창하지 않는다. <br/>
또한 Key를 직접 포함할 필요 없이 어떤 객체의 몇번째 필드인지 필드번호를 이용해 표기한다. <br/>
ex. ```<field number><wire type><data>``` (간단한 예시일 뿐 라이브러리마다 조금 다를 수 있다.) <br/>

또, JSON은 변환하는데 자원을 소모할 수밖에 없지만 protoBuf는 바이너리데이터를 복사하여 파라미터를 기록할 수 있기 때문에 오버헤드가 적다.
