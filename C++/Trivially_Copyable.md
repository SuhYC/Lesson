# Trivially Copyable
## 일반적 복사 가능

직렬화를 가장 쉽게 구현하는 방법은 객체가 가지고 있는 데이터를 그대로 스트림에 복사해서 직렬화하는 방식이다. <br/>
당연히 객체도 메모리에 특정주소부터 특정주소까지 데이터를 저장하여 표현하기 때문에, <br/>
객체가 가지는 메모리영역을 그대로 버퍼에 복사하면 객체의 특성을 직렬화할 수 있게 되는 것이고, <br/>
이를 메모리 정렬 및 패딩과 엔디안을 통일한 방법으로 다시 객체에 해당하는 메모리영역에 복사하면 역직렬화가 되는 것이다. <br/>

## 동적할당 메모리는?
이 부분에서 문제가 되는 것이 동적할당 메모리이다. <br/>
런타임에 할당되는 메모리는 그 크기를 컴파일 시간에 알 수 없고, <br/>
그렇기 때문에 객체마다 다른 크기를 가질 수 있기에 일괄적인 처리가 불가능하다. <br/>
그런 경우에는 [멤버변수마다 직렬화를 요청하는 방식](https://github.com/SuhYC/DIY/tree/main/SerializeLib/Cpp)으로 구현하여야한다. <br/>

## 템플릿 함수로 만들고 싶은데?
직렬화 라이브러리를 새로운 객체가 생길 때마다 작성하는 것은 상당히 번거로운 일이다. <br/>
이를 템플릿 함수를 통해 처리할 수 있지만, 주의해야할 부분이 있다. <br/>
템플릿 함수에서 동적할당 메모리가 포함된 객체는 걸러주어야하는 것. <br/>
동적할당 메모리가 포함된 객체는 별도로 일반함수로 오버로딩하여 표현하고, 동적할당 메모리가 없는 객체는 템플릿함수로 구현하면 되는 것이다. <br/>

## 그럼 동적할당 여부는 어떻게 구분할건데?
그때 나오는 기능이 바로 ```std::is_trivially_copyable<T>::value```이다. <br/>
템플릿 구조체의 형식을 띄고 있는데, 몇가지 속성을 점검하여 해당 객체가 memcpy로 복사해도 안전한지 판단한다. <br/>
```trivially copyable```은 다음과 같은 조건을 갖는데, <br/>
사용자가 직접 정의한 생성자, 소멸자, 복사생성자, 이동생성자, 대입연산자와 같은 함수가 없어야한다. <br/>

## 그럼 초기화는?
생성자가 아닌 일반함수에서 시도하면 된다. <br/>
흔히 void Init(...)와 같은 함수로 초기화하는 경우가 있지 않나?

## 근데 일반함수에서 동적할당을 하면 어떡해?
그것까지 잡아내지는 못한다. (이정도까지 왔으면 그냥 그 사람이 뚫고 싶은 걸지도 모른다..) <br/>
그래서 일반적으로는 네트워크송수신을 위한 메시지는 POD객체를 권장한다. <br/>
### Plain Old Data
Trivially Copyable하고, Standard Layout을 만족하는 객체이다. <br/>
직접 정의한 생성자, 소멸자, 복사생성자, 이동생성자, 대입연산자가 없으면서, <br/>
Cstyle 구조체처럼 멤버 메모리 배치가 단순하고, 상속, 가상함수, 다중 접근제어가 없는 객체를 의미한다. <br/>
다중 접근제어란 private, public, protected 등의 접근제어자가 2개이상 혼용된 경우를 의미한다. <br/>
동적할당 데이터 없이 고정크기를 갖도록 하고, 객체 외부에서 그냥 멤버에 접근할 수 있도록 하고, 별도의 함수를 작성하지 않는 것으로 충분. <br/>

## std::is_pod
C++20부터는 deprecated되었다. <br/>
이유는, pod의 개념이 조금 모호한 감이 있고, trivially copyable과 standard layout을 점검하면 되기 때문에 굳이 복합적인 점검을 하지 않는게 낫기 때문. <br/>
```std::is_trivially_copyable<T> && std::is_standard_layout<T>```로 점검하는 것으로 대체하도록 하자.
