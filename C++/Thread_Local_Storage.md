# Thread Local Storage
## 스레드 로컬 저장소
스레드가 각자 자신만의 변수 복사본을 가지게 하는 기술

## 지역성
스레드가 각자 접근할 수 있는 메모리를 가지게 되는 것이므로 락 없이 접근가능하다. <br/>
대신 다른 스레드에서 직접 접근할 수 없다. 동기화가 필요하다면 다른 변수를 통해야한다. <br/>
스레드의 지역변수로 동작하지만 해당 스레드 내에서는 전역변수처럼 접근 가능하다. <br/>

## 지연 초기화 (lazy initialization)
해당 변수에 스레드가 접근하기 전까지는 해당 변수가 선언되지 않는다. <br/>
어떤 스레드에는 어떤 변수가 필요하고, 다른 스레드에는 다른 변수가 필요하다면 필요한 변수만 접근하면 해당 변수가 선언되고 사용할 수 있다. <br/>

## 장점
1. 스레드 안전성 - 락 없이 안전한 사용 가능
2. 성능향상 - 다른 스레드가 접근할 일이 없어 락을 걸지 않음
3. 리소스 관리 쉬움 - 스레드의 수명과 동일한 수명을 가짐. 다만 힙메모리 관리는 해주어야한다. 스택메모리는 회수된다.

## 단점
1. 공유불가 - 스레드마다 가지는 독립적인 메모리라 다른 스레드에서 접근 안됨
2. 디버깅 어려움 - 스레드마다 가지는 값이다보니 디버깅에 혼란을 줌
3. 메모리 사용량 증가 - 해당 변수를 사용하는 스레드가 많아질 수록 당연히 메모리를 할당하여 소비하게 됨
4. 리소스 해제 주의 - 힙메모리 사용에 주의할 것. 특히 어떤 스레드는 TLS에 힙메모리 할당을 하고, 어떤 스레드는 하지 않는다면 해제해야한다는 것을 잊기 쉽다.
5. 초기화 순서 주의 - 해당 스레드 내에서 TLS가 할당되어 초기화되기 전에 접근하면 쓰레기값을 읽기 쉬움.

## C++ 사용 예

```cpp
thread_local int tls_cnt = 0; // TLS를 사용할 수 있다고 선언!

void Do()
{
  for(int i = 0; i < 3; i++)
  {
    tls_cnt++;                // 여기부터 lazy initialization되어 사용할 수 있다!
    std::cout << tls_cnt << '\n'; // 스레드마다 각자 증가시키고 출력하겠지?
  }
}

int main()
{
  std::thread t1(Do);
  std::thread t2(Do);

  t1.join();
  t2.join();
  return 0;
}
```
