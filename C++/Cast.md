# Cast
기존 타입을 다른 타입으로 변환하는 동작

## C style Cast
```cpp
  int a = 65;
  float f = (float)a; // C-style Cast!
```
C언어에서 사용하던 캐스팅방법. C++에서도 마찬가지로 지원한다.<br/>
C++의 캐스트 기능을 포함하지만 의도가 분명히 드러나지 않으므로 에러가 발생하기 쉽다.<br/>
예상과 다른 결과를 불러올 수 있으니 가급적 C++의 캐스트를 사용하자.

## static_cast
컴파일 시간에 정적으로 수행하는 캐스트 방법. <br/>
```cpp
  int i = 3; j = 4;
  double result = static_cast<double>(i) / j; // static cast!
```
위 코드에서 int형데이터를 int형데이터로 나누면 정수의 나눗셈(소수점 이하 버림)이 되므로 <br/>
부동소수점 나눗셈을 적용하기 위해 i의 데이터를 double로 받아와 연산하였다. <br/>

클래스의 인스턴스에서도 상속계층의 하위타입으로 다운캐스트할때도 사용할 수 있다. <br/>
이 경우 객체에 직접 적용할 수 없고 레퍼런스나 포인터에 적용해야한다.
```cpp
  Base* b = nullptr;
  Derived* d = new Derived{};
  b = d; // 상속계층의 상위타입이므로 명시적 캐스트할 필요 없다.
  d = static_cast<Derived*>(b); // 하위타입으로 다운캐스트해야한다.
```
하지만 유의해야하는데, 런타임에 타입을 검사하지 않으므로 예상치 못한 결과가 발생할 수 있다. <br/>
```cpp
  Base* b = new Base{};
  Derived* d = static_cast<Derived*>(b); // Error!
```
이전 코드와 다른 것은 객체의 생성 시점에 어떤 객체였냐는 것이다. <br/>
이전 코드는 자식클래스의 객체가 부모클래스 포인터로 이동했다가, 자식클래스 포인터로 온 경우다.<br/>
하지만 이번 코드는 부모클래스의 객체가 자식클래스의 포인터로 온 경우로,<br/>
부모클래스의 인스턴스는 자식클래스의 인스턴스보다 할당받은 메모리영역이 작다. (자식클래스에 따로 선언한게 아무것도 없는 경우는 제외)<br/>
이 경우엔 ```dynamic_cast```를 사용하는 것이 좋다.

일반적으로 관련이 없는 타입간의 캐스트는 불가능하고, const 타입을 비const타입으로 변환할 수도 없다.<br/>
포인터 간의 캐스트도 static_cast를 쓰지 않는것이 좋다.

## reinterpret_cast
```static_cast```에 비해 강력하지만 안전성이 떨어지는 캐스트.<br/>
C++의 타입규칙에서 허용하지 않아도 상황에 따라 적합하다면 캐스트가 가능하다.<br/>

하지만 타입체크를 하지 않기 때문에 예기치 않은 동작이 발생할 수 있다. <br/>
가볍게는 ```int*```와 ```float*```의 형변환에 사용할 경우, 같은 4바이트이지만 그 안에 담긴 데이터를 해석하는 방식이 ```int```와 ```float```은 다르다. <br/>
```int*```로는 데이터를 ```4```를 담아두었을지 몰라도 ```float*```으로 형변환 한 경우 그 안의 데이터는 ```4.0f```이 아니다.<br/>

또한 위에서 설명한 객체를 가리키는 포인터도 같은 문제를 발생시킬 수 있다.<br/>
생성할 때의 인스턴스 메모리크기보다 큰 인스턴스를 갖는 클래스의 객체 포인터에 형변환하여 담은 경우,<br/>
담고 있는 포인터에서 참조할 수 있는 영역에 비해 실제 할당된 영역이 작으므로 메모리 참조 문제가 발생할 수 있고,<br/>
두 클래스의 인스턴스 크기가 같다고 할지라도 그 인스턴스의 멤버에 접근하는 경우에도 문제가 발생할 수 있다.

## std::bit_cast
헤더 ```<bit>```에 정의되어 있으며 C++20부터 추가되었다.<br/>
표준 라이브러리에 속한 유일한 캐스트이다. 다른 캐스트는 모두 C++언어의 일부다.<br/>
```reinterpret_cast```와 비슷하게 동작하지만, 크기가 다른 타입간에는 컴파일에러가 발생한다.<br/>
동일한 크기에만 사용할 수 있으므로 잘못된 메모리 접근을 막을 수 있다.

## dynamic_cast
같은 상속계층 내 캐스트에 대한 런타임 검사를 제공한다. 포인터나 레퍼런스에 사용할 수 있다.<br/>
캐스트하는 것이 적합하지 않은 경우 포인터는 ```nullptr```를 리턴하고, 레퍼런스는 ```std::bad_cast``` 익셉션을 발생시킨다.<br/>
```dynamic_cast```를 적용하기 위해서는 클래스가 하나 이상의 virtual메소드를 포함하여야한다.<br/>
vtable을 가리킬 공간이 필요한데, virtual메소드가 없는 경우 문제가 생길 수 있기 때문. 이 경우 컴파일에러가 발생한다.

## const_cast
const 속성을 추가하거나 제거하는 캐스트이다.<br/>
const의 목적을 생각할 때 일반적으로 사용할 일이 없는 것이 가장 바람직하겠지만,<br/>
서드파티 라이브러리처럼 수정할 수 없는 경우에 const 속성을 없애야하는 경우가 생긴다.<br/>
이러한 경우에만 제한적으로 사용한다.<br/>
물론 호출할 서드파티 라이브러리의 함수가 해당 매개변수를 변경하지 않는다고 보장하는 경우에 이렇게 처리해야한다.

# 캐스트에 적합한 상황 정리
1. const 속성 제거 : ```const_cast```
2. 언어에서 허용하는 명시적 변환 : ```static_cast```
3. 사용자 정의 생성자나 변환 연산자에서 지원하는 명시적 변환 : ```static_cast```
4. 관련 없는 타입의 객체끼리 변환 : ```std::bit_cast```
5. 같은 상속 계층에 있는 클래스 타입의 객체 포인터, 레퍼런스 사이의 변환 : ```dynamic_cast```권장. ```static_cast```도 제한적 가능.
6. 서로 관련 없는 포인터, 레퍼런스 사이의 변환 : ```reinterpret_cast```
7. 함수 포인터 사이의 변환 : ```reinterpret_cast```
