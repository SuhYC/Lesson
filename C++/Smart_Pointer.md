# Smart_Pointer
## 스마트포인터

C++의 가장 중요한 포인트는 무엇일까? <br/>
여러가지 꼽을 수 있겠지만 메모리관리는 빠지지 않고 나오는 C++의 핵심포인트이다. <br/>
메모리를 할당하고 해제하지 않아 메모리누수가 발생한다던가, <br/>
이미 해제한 주소를 다시 해제하려고 시도하거나 해당 주소에 접근한다면 문제가 발생할 수 있다.

이러한 문제를 쉽게 해결하기 위해 스마트포인터 라는 것을 사용한다.

### Shared Pointer
레퍼런스 카운터를 사용하여 아무도 해당 객체를 가리키고 있지 않을 때 해제해주는 포인터이다.

### Weak Pointer
Shared Pointer의 Circular Reference를 해결하기 위해 있는 포인터. 해당 포인터가 가리키고 있는 주소가 유효한 지 확인할 수 있다.<br/>
Shared Pointer로부터 받은 주소를 가리킬 수 있지만, Shared Pointer의 RefCount는 증가시키지 않는다.<br/>
하지만 RefCount를 증가시키지 않기 때문에 Weak Pointer가 가리키고 있는 주소가 해제되었는지는 확실하지 않다. <br/>
다행히도 Weak Pointer는 해당 주소가 해제되었는지를 확인 가능하다. <br/>
직접 메모리관리에 관여하지는 않지만 Circular Reference에 대처가능하다.

### Unique Pointer
복사가 불가능하다. 한번에 하나의 포인터만 주소를 가리킬 수 있도록 하는 것이다. <br/>
다른 포인터가 해당 주소를 접근하려면 주소의 소유권을 이전하여야한다.

### Auto Pointer
사용이 권장되지 않으며 대부분 사용불가하다. <br/>
Unique Pointer를 사용하도록 하자.

### deleter
가지고 있는 원시포인터가 배열포인터인지 단일포인터인지 스마트포인터 스스로는 알 수 없다. <br/>
new로 할당된 포인터는 delete로 해제되어야하고 new[]로 할당된 포인터는 delete[]로 해제되어야한다. <br/>
이를 해결하기 위해 deleter의 개념이 사용된다. <br/>
해당 포인터가 new[]로 선언되었다면, delete[]를 호출하는 함수를 만들어 deleter인자로 함수포인터를 넘겨주면 되는 것이다. <br/>
복잡한 구조의 포인터가 있다면 이 또한 deleter 내에서 다 처리할 수 있도록 하자. (ex. WSABUF, WSABUF.buf 둘다 해제되어야되는 경우)
