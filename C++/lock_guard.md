# std::lock_guard (C++11)
## RAII mutex

멀티스레드는 작은 실수로 치명적인 오류가 발생하기도 한다.   
그 중 하나는 mutex.lock()을 호출한 후, mutex.unlock()을 호출하는 것을 잊은 경우이다.   
해당 mutex를 얻은 스레드라고 할지라도 unlock()을 호출하지 않고 다시 lock()을 호출하는 경우 해당 스레드도 unlock을 기다리는 상태가 된다.   
(이미 mutex를 소지한 스레드가 해당 mutex에 lock을 재호출하는 경우에도 괜찮은 recursive_mutex도 있긴하다.)   

일반적인 케이스를 생각하며 unlock()을 적어둔 경우도 문제가 될 수 있는데,   
Critical Session 내에 코드가 길어져 도중에 return하는 경우,   
예외처리 발생 후 처리하는 코드에서 unlock을 잊은 경우 등이 있다.

어떤식으로든 mutex의 lock을 얻었다면 unlock해주어야하는데, 사람은 실수하기 마련이다.   
이 실수를 방지하기 위한 방법이 바로 LockGuard이다.   
RAII형식으로 구성하여 해당 Scope를 벗어날 때, 객체가 해제되며 소멸자가 호출되고 소멸자에서 unlock을 호출하는 것이다.

### std::scoped_lock (C++17)
C++17에서 추가된 기능으로, lock_guard와 기본적인 원리는 동일하나, 동시에 여러개의 mutex를 인자로 넘길 수 있다.

### std::unique_lock (C++11)
lock_guard와 기본적인 원리는 동일하나, 락을 걸 수 있는 시점을 지정할 수 있다.   
또한 moveable하다. (scope 제한을 어느정도 확장할 수 있다.)

### std::shared_lock (C++14)
읽기 동작과 쓰기 동작은 공유자원에 대해 다른 권한을 요구한다.   
쓰기 동작은 자신 외에 어떤 스레드도 접근하면 안된다.   
읽기 동작은 쓰기 동작을 수행하는 스레드와만 충돌하지 않으면 된다.   
이를 바탕으로 읽기 동작은 쓰기 동작을 수행하는 스레드가 없으면 진입할 수 있도록 하고, 쓰기 동작은 그 어떤 스레드도 공유자원에 접근하지 않은 경우에 진입할 수 있게 도와주는 lock이다.
