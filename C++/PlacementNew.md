# Placement New

이미 할당 받은 메모리에 새로운 객체를 생성하는 방법이다. <br/>
동적메모리를 할당하는 경우 운영체제로부터 사용할 메모리를 받아와서 해당 메모리를 사용해 객체를 생성하게되는데, <br/>
Placement New는 운영체제로부터 새로 메모리를 받아올 필요 없이 기존에 사용하던 메모리에 객체를 덮어씌워 사용할 수 있게 된다. <br/>
운영체제로부터 메모리를 할당받는 오버헤드가 줄어드니 당연히 new에 비해 적은 오버헤드로 객체를 생성할 수 있다. (객체 생성과 초기화에 대한 오버헤드는 동일하다.)

```cpp
class A
{
public:
	A()
	{
		std::cout << "A\n";
	}
	~A()
	{
		std::cout << "~A\n";
	}
};

class B
{
public:
	B()
	{
		std::cout << "B\n";
	}
	~B()
	{
		std::cout << "~B\n";
	}
};
int main()
{
	A* pA = new A(); // A가 출력된다.

  // pA->~A(); 소멸자를 호출해야한다면 ~A()를 따로 호출해주어야한다.
	B* pB = new(pA)B(); // B가 출력된다.

	std::cout << pA << "\n"; // 두 메모리 주소가
	std::cout << pB << "\n"; // 동일하게 출력된다.

	delete pB; // ~B가 출력된다. !! 해제한 메모리는 A로서가 아닌 B로서이다. !!

	return 0;
}
```

위 코드를 실행해보면
```
A
B
000001B7F3D380A0 // 할당받은 메모리의 주소니 매 실행마다 다를 수 있다.
000001B7F3D380A0
~B
```
와 같이 출력된다. <br/>
주석처리한 pA->~A();와 같이 소멸자를 명시호출해주지 않으면 A객체로서의 소멸자가 호출되지 않는다.
