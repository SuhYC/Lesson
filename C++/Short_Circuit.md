# 단락평가
논리연산이 후열에 오는 피연산자와 관계없이 그 값이 결정된 경우 후열의 피연산자 값을 고려하지 않고 값을 결정하는 것. <br/>

```cpp
bool bRet = false && SomeBoolReturnMethod(); // false && 에서 이미 SomeBoolReturnMethod()는 확인하지 않아도 false로 값이 결정되기 때문에 실행하지 않는다!
```

이러한 성질을 이용하여 인덱스체크를 먼저 함으로서 후열에 오는 인덱스 접근이 혹시라도 문제가 생기지 않도록하는 방법은 흔히 알려져 있다. <br/>

## 이건 알고 있었니?
```&=``` 연산자는 단락평가를 하지 않는다. <br/>
일단 비트연산자니까 그럴 수 있다고 생각이 들 수도 있지만 <br/>
C++에는 일단 ```&&=``` 연산자가 없다. <br/>
그러니 ```&&=```연산자 대신 ```&=```연산자나 써야겠다 라고 생각할 수 있는데 <br/>
이 부분에서 문제가 생길 수 있다는 것이다. <br/>
단락평가를 하지 않고 끝까지 실행하기 때문에 선행조건을 만족하지 않아 후행연산을 하면 안되는 상황이라고 하더라도 ```&=```연산자를 사용함으로서 후행연산까지 해버리거나, <br/>
혹은 후행연산이 필요하지 않은 상황임에도 후행연산을 모두 실행하여 괜한 자원낭비를 할 수도 있다는 것.

```cpp
bool bRet = false;
bRet &= SomeBoolReturnMethod(); // false에 &=연산을 하더라도 그 값이 변하지 않는데도 불구하고 굳이굳이 SomeBoolReturnMethod()는 실행된다..
```

모든 동작이 성공적으로 수행되어야하는 경우가 있다면 굳이 ```&=```를 쓰지 말고 early-return을 하자.
