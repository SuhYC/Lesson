# 스마트 포인터 생성 함수
스마트포인터는 해당 스마트포인터의 생성자를 통해 생성할 수도 있지만, ```std::make_shared```와 ```std::make_unique```로도 생성할 수 있다. <br/>
생성자를 통해 생성하는 것보다 생성함수를 통해 생성하는 것을 권장한다.

## 왜 생성자보다 생성함수를 권장하지?
그 이유로 몇가지를 들 수 있는데,
### 메모리 할당 횟수
스마트포인터는 2가지 메모리를 관리하여야한다. <br/>
첫번째는 당연히 가리킬 객체이다. 객체의 포인터를 가지고 보관하여야한다. <br/>
두번째는 가리킬 객체에 대한 정보로, ```refCount```와 같이 몇개의 스마트포인터가 해당 주소를 가리키는지 등과 같은 정보를 담을 ```Control Block```의 메모리이다. <br/>
만약 다음과 같이 코드를 작성한다면 어떻게 될까? <br/>
```cpp
std::shared_ptr<MyClass> ptr = std::shard_ptr<MyClass>(new MyClass());
```
생성자에 진입하기 전, ```new MyClass()``` 부분에서 먼저 메모리를 1회 할당한다. <br/>
이후 생성자 내부에서 해당 포인터를 보관할 ```control Block```을 만들기 위해 메모리를 1회 할당한다. <br/>
하나의 스마트 포인터를 만들기 위해 2번의 메모리 할당이 필요한 것이다. <br/>

하지만 다음과 같이 코드를 작성한다면 어떻게 될까? <br/>
```cpp
std::shared_ptr<MyClass> ptr = std::make_shared<MyClass>();
```
생성함수에 진입하여 객체의 정보를 저장할 공간과, 스마트포인터의 정보를 담을 공간을 한번에 크게 할당받는다. <br/>
이후 해당 공간에 객체와 ```control Block```의 데이터를 한번에 저장한다. <br/>

전자의 방법으로는 2번의 메모리 할당을 요청하기에 그에 맞는 오버헤드가 발생하고, 후자의 방법으로는 1번의 메모리 할당을 요청하기에 비교적 적은 오버헤드가 발생한다.

### 예외 안전성
메모리를 할당하는 동작은 예외를 발생시킬 수 있다. <br/>
더 이상 메모리를 할당할 수 없을 때, 예외가 발생하며 이를 처리해주어야한다. <br/>
만약 생성자를 통해 스마트포인터를 생성하는 경우에는 어떨까? <br/>
```cpp
try
{
  std::shared_ptr<MyClass> ptr = std::shard_ptr<MyClass>(new MyClass());
}
catch (std::bad_alloc e)
{
  //...
}
```
위 코드에서 만약 ```new MyClass()```는 정상적으로 실행되었는데, 생성자 내부에서 ```control Block```을 할당하지 못해 예외가 발생했다면 어떻게 될까? <br/>
생성자에서 예외가 발생하는 경우. 굉장히 치명적인 케이스이다. <br/>
소멸자에서 사용이 끝난 메모리를 정리하게 되는데 생성자에서 예외가 발생하면 그건 객체가 생성된게 아니다. <br/>
그렇기 때문에 생성자에서 예외가 발생하면 소멸자의 도움을 받을 수 없다. <br/>
결국 ```new MyClass()```로 할당한 메모리는 소멸자의 도움을 받지 못한 채 스택풀기가 되며 메모리누수가 발생하게 된다. <br/>

그러면 생성함수를 통해 스마트포인터를 생성하는 경우는 어떨까? <br/>
```cpp
try
{
  std::shared_ptr<MyClass> ptr = std::make_shared<MyClass>();
}
catch (std::bad_alloc e)
{
  //...
}
```
위 코드에서는 ```control Block```과 객체를 저장할 공간을 한번에 할당받는다. <br/>
즉, 메모리 할당에 실패했다면, 객체를 할당하는 데에도 실패했다는 뜻이므로 해제해야할 메모리가 없기 때문에 메모리 누수가 발생하지 않는다.

## 단점
```custom deleter```를 사용할 수 없다. <br/>
사용하려면 생성자를 사용해야한다..
